<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The LitLyric Narrator Project</title>

    <!-- Firebase SDK - Compat version for Firestore/Storage -->
    <script src="https://www.gstatic.com/firebasejs/11.8.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.8.1/firebase-storage-compat.js"></script>

    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(
          135deg,
          #0a1628 0%,
          #0d2137 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        color: #e8e8e8;
        padding: 2rem;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 2rem;
      }

      .header-logo {
        width: 80px;
        height: 80px;
        margin-bottom: 1rem;
      }

      h1 {
        font-size: 2.2rem;
        font-weight: 300;
        margin-bottom: 0.5rem;
        background: linear-gradient(90deg, #0066ff, #00aaff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .subtitle {
        color: #8892a0;
      }

      .version-badge {
        display: inline-block;
        margin-top: 0.5rem;
        padding: 0.2rem 0.8rem;
        font-size: 0.7rem;
        color: #6b7280;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        letter-spacing: 1px;
      }

      .request-change-btn {
        padding: 0.75rem 1.5rem;
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .request-change-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
      }

      .report-btn {
        padding: 0.75rem 1.5rem;
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid rgba(239, 68, 68, 0.5);
        border-radius: 8px;
        color: #f87171;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .report-btn:hover {
        background: rgba(239, 68, 68, 0.3);
      }

      /* Existing Profile Card */
      .existing-profile-card {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        overflow: hidden;
        margin-top: 1rem;
        animation: fadeIn 0.5s ease;
      }

      .existing-profile-header {
        display: flex;
        align-items: center;
        gap: 2rem;
        padding: 2rem;
        background: rgba(0, 0, 0, 0.2);
      }

      .existing-profile-image {
        width: 150px;
        height: 150px;
        border-radius: 50%;
        overflow: hidden;
        flex-shrink: 0;
        background: rgba(255, 255, 255, 0.05);
      }

      .existing-profile-image img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .no-image-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #6b7280;
        font-size: 0.9rem;
      }

      .existing-profile-info {
        flex: 1;
      }

      .database-badge {
        display: inline-block;
        background: linear-gradient(135deg, #0066ff, #00aaff);
        color: white;
        padding: 0.3rem 0.8rem;
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .existing-profile-info h2 {
        font-size: 2rem;
        font-weight: 600;
        color: #fff;
        margin: 0;
      }

      .existing-profile-bio {
        padding: 2rem;
      }

      .existing-profile-bio h3 {
        color: #00aaff;
        font-size: 1rem;
        margin-bottom: 1rem;
      }

      .existing-profile-bio p {
        color: #ccc;
        line-height: 1.7;
        font-size: 0.95rem;
      }

      .existing-profile-actions {
        display: flex;
        gap: 1rem;
        padding: 1.5rem 2rem;
        background: rgba(0, 0, 0, 0.2);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      @media (max-width: 600px) {
        .existing-profile-header {
          flex-direction: column;
          text-align: center;
        }

        .existing-profile-actions {
          flex-direction: column;
        }

        .existing-profile-actions button {
          width: 100%;
        }
      }

      /* Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 1rem;
      }

      .modal-content {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 2rem;
        max-width: 500px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
      }

      .modal-content h3 {
        margin-bottom: 0.5rem;
        color: #fff;
      }

      .modal-content > p {
        color: #8892a0;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
      }

      .modal-form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .modal-form label {
        color: #ccc;
        font-size: 0.9rem;
      }

      .modal-form textarea,
      .modal-form input[type="email"] {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 0.75rem;
        color: #fff;
        font-size: 0.9rem;
        resize: vertical;
      }

      .modal-form textarea {
        min-height: 80px;
      }

      .modal-form textarea:focus,
      .modal-form input:focus {
        outline: none;
        border-color: #0066ff;
      }

      .checkbox-group,
      .radio-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        padding: 0.5rem 0;
      }

      .checkbox-group label,
      .radio-group label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
        color: #aaa;
      }

      .checkbox-group input,
      .radio-group input {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .modal-cancel {
        padding: 0.75rem 1.5rem;
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: #aaa;
        cursor: pointer;
        transition: all 0.2s;
      }

      .modal-cancel:hover {
        background: rgba(255, 255, 255, 0.05);
      }

      .modal-submit {
        padding: 0.75rem 1.5rem;
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }

      .modal-submit:hover {
        transform: translateY(-2px);
      }

      .modal-submit.report {
        background: linear-gradient(135deg, #ef4444, #dc2626);
      }

      .modal-submit:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .search-container {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
      }

      .search-input {
        flex: 1;
        padding: 1rem 1.5rem;
        font-size: 1.1rem;
        border: none;
        border-radius: 50px;
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        outline: none;
      }

      .search-input::placeholder {
        color: #6b7280;
      }

      .search-input:focus {
        background: rgba(255, 255, 255, 0.15);
        box-shadow: 0 0 20px rgba(0, 102, 255, 0.3);
      }

      .search-btn {
        padding: 1rem 2rem;
        font-size: 1.1rem;
        font-weight: 600;
        border: none;
        border-radius: 50px;
        background: linear-gradient(135deg, #0066ff, #00aaff);
        color: #fff;
        cursor: pointer;
      }

      .search-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(0, 102, 255, 0.4);
      }

      .search-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .loading {
        display: none;
        text-align: center;
        padding: 3rem;
      }

      .loading.active {
        display: block;
      }

      .spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(255, 255, 255, 0.1);
        border-top-color: #0066ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1rem;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .source-progress {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .source-status {
        padding: 0.3rem 0.8rem;
        border-radius: 20px;
        font-size: 0.75rem;
        background: rgba(255, 255, 255, 0.05);
        color: #6b7280;
      }

      .source-status.searching {
        background: rgba(0, 102, 255, 0.2);
        color: #0066ff;
        animation: pulse 1.5s infinite;
      }

      .source-status.found {
        background: rgba(34, 197, 94, 0.2);
        color: #22c55e;
      }

      .source-status.not-found {
        background: rgba(239, 68, 68, 0.1);
        color: #6b7280;
        text-decoration: line-through;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .result-card {
        display: none;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .result-card.active {
        display: block;
        animation: fadeIn 0.5s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .profile-header {
        display: flex;
        gap: 2rem;
        padding: 2rem;
        background: rgba(0, 0, 0, 0.2);
      }

      .profile-image {
        width: 150px;
        height: 150px;
        border-radius: 50%;
        object-fit: cover;
        border: 4px solid rgba(0, 102, 255, 0.5);
        background: rgba(255, 255, 255, 0.1);
      }

      .profile-placeholder {
        width: 150px;
        height: 150px;
        border-radius: 50%;
        border: 4px solid rgba(0, 102, 255, 0.5);
        background: rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 4rem;
      }

      .profile-info {
        flex: 1;
      }

      .narrator-name {
        font-size: 1.8rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .narrator-tagline {
        color: #00aaff;
        font-style: italic;
        margin-bottom: 1rem;
      }

      .source-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .source-badge {
        padding: 0.25rem 0.75rem;
        background: rgba(0, 102, 255, 0.2);
        border-radius: 20px;
        font-size: 0.75rem;
        color: #0066ff;
      }

      .profile-body {
        padding: 2rem;
      }

      .section {
        margin-bottom: 2rem;
      }

      .section h3 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: #00aaff;
      }

      .bio-text {
        line-height: 1.8;
        color: #c8c8c8;
        white-space: pre-line;
      }

      .tags-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .tag {
        padding: 0.4rem 0.8rem;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        font-size: 0.85rem;
        color: #a8a8a8;
      }

      .tag.award {
        background: rgba(245, 166, 35, 0.15);
        color: #00aaff;
      }

      .sources-section {
        margin-top: 2rem;
        padding-top: 1.5rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .sources-section h4 {
        font-size: 0.85rem;
        margin-bottom: 0.75rem;
        color: #6b7280;
      }

      .sources-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .source-link {
        padding: 0.4rem 0.8rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 6px;
        font-size: 0.8rem;
        color: #8892a0;
        text-decoration: none;
      }

      .source-link:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #0066ff;
      }

      /* Selection sections */
      .selection-section {
        padding: 1.5rem 2rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .selection-section h3 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: #00aaff;
      }

      .image-options {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .image-option {
        position: relative;
        cursor: pointer;
        border-radius: 12px;
        overflow: hidden;
        border: 3px solid transparent;
        transition: all 0.2s ease;
      }

      .image-option:hover {
        border-color: rgba(0, 102, 255, 0.5);
      }

      .image-option.selected {
        border-color: #0066ff;
        box-shadow: 0 0 20px rgba(0, 102, 255, 0.4);
      }

      .image-option img {
        width: 120px;
        height: 120px;
        object-fit: cover;
        display: block;
      }

      .image-option-info {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
        padding: 0.5rem;
        font-size: 0.7rem;
      }

      .image-option-source {
        color: #00aaff;
        font-weight: 600;
      }

      .image-option-score {
        color: #888;
      }

      .image-option-check {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 24px;
        height: 24px;
        background: #0066ff;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 14px;
      }

      .image-option.selected .image-option-check {
        display: flex;
      }

      .bio-options {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .ai-generate-btn {
        padding: 0.75rem 1.5rem;
        background: linear-gradient(135deg, #667eea, #764ba2);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 0.9rem;
      }

      .ai-generate-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .ai-generate-btn:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
      }

      .ai-generate-btn.generating {
        background: linear-gradient(135deg, #00aaff, #0066ff);
      }

      .fast-mode-toggle {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.8rem;
        color: #8892a0;
        margin-left: 1rem;
      }

      .fast-mode-toggle input {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .bio-option {
        padding: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        border: 2px solid transparent;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .bio-option:hover {
        border-color: rgba(0, 102, 255, 0.3);
        background: rgba(255, 255, 255, 0.08);
      }

      .bio-option.selected {
        border-color: #0066ff;
        background: rgba(0, 102, 255, 0.1);
      }

      .bio-option-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
      }

      .bio-option-source {
        color: #00aaff;
        font-weight: 600;
        font-size: 0.85rem;
      }

      .bio-option-length {
        color: #666;
        font-size: 0.75rem;
      }

      .bio-option-text {
        color: #c8c8c8;
        font-size: 0.9rem;
        line-height: 1.6;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .bio-option.selected .bio-option-text {
        -webkit-line-clamp: unset;
      }

      .bio-option-check {
        width: 20px;
        height: 20px;
        border: 2px solid #666;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .bio-option.selected .bio-option-check {
        background: #0066ff;
        border-color: #0066ff;
        color: white;
      }

      /* Export section */
      .export-section {
        padding: 1.5rem 2rem;
        background: rgba(0, 0, 0, 0.2);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .export-section h3 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: #00aaff;
      }

      #exportData {
        background: rgba(0, 0, 0, 0.3);
        padding: 1rem;
        border-radius: 8px;
        font-family: monospace;
        font-size: 0.75rem;
        color: #a8a8a8;
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-all;
        max-height: 200px;
        overflow-y: auto;
      }

      .export-btn {
        margin-top: 1rem;
        padding: 0.75rem 1.5rem;
        background: linear-gradient(135deg, #0066ff, #00aaff);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }

      .export-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(0, 102, 255, 0.4);
      }

      .firebase-btn {
        margin-top: 1rem;
        margin-left: 1rem;
        padding: 0.75rem 1.5rem;
        background: linear-gradient(135deg, #4caf50, #45a049);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }

      .firebase-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
      }

      .firebase-btn:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .firebase-btn.uploading {
        background: linear-gradient(135deg, #ff9800, #f57c00);
      }

      .firebase-btn.success {
        background: linear-gradient(135deg, #4caf50, #2e7d32);
      }

      .firebase-btn.error {
        background: linear-gradient(135deg, #f44336, #c62828);
      }

      .firebase-config {
        margin-top: 1rem;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        display: none;
      }

      .firebase-config.show {
        display: block;
      }

      .firebase-config label {
        display: block;
        margin-bottom: 0.25rem;
        color: #00aaff;
        font-size: 0.85rem;
      }

      .firebase-config input {
        width: 100%;
        padding: 0.5rem;
        margin-bottom: 0.75rem;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        color: white;
        font-size: 0.85rem;
      }

      .firebase-config input:focus {
        outline: none;
        border-color: #4caf50;
      }

      .firebase-status {
        margin-top: 0.5rem;
        padding: 0.5rem;
        border-radius: 6px;
        font-size: 0.85rem;
        display: none;
      }

      .firebase-status.show {
        display: block;
      }

      .firebase-status.success {
        background: rgba(76, 175, 80, 0.2);
        color: #81c784;
      }

      .firebase-status.error {
        background: rgba(244, 67, 54, 0.2);
        color: #e57373;
      }

      .config-toggle {
        background: none;
        border: none;
        color: #888;
        cursor: pointer;
        font-size: 0.8rem;
        text-decoration: underline;
        margin-top: 0.5rem;
      }

      .config-toggle:hover {
        color: #00aaff;
      }

      .no-options {
        color: #666;
        font-style: italic;
        padding: 1rem;
      }

      .no-image-option {
        width: 120px;
        height: 120px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.05);
        color: #888;
      }

      .no-image-option span {
        font-size: 2rem;
        margin-bottom: 0.5rem;
      }

      .no-image-option small {
        font-size: 0.75rem;
      }

      .custom-image-option {
        width: 120px;
        height: 120px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(0, 102, 255, 0.1);
        color: #0066ff;
        border: 2px dashed rgba(0, 102, 255, 0.3);
        border-radius: 8px;
      }

      .custom-image-option span {
        font-size: 2rem;
        margin-bottom: 0.5rem;
      }

      .custom-image-option small {
        font-size: 0.75rem;
      }

      .custom-input-container {
        margin-top: 1rem;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        border: 1px solid rgba(0, 102, 255, 0.3);
      }

      .custom-input-container label {
        display: block;
        margin-bottom: 0.5rem;
        color: #00aaff;
        font-weight: 600;
        font-size: 0.9rem;
      }

      .custom-input-container input,
      .custom-input-container textarea {
        width: 100%;
        padding: 0.75rem;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 0.9rem;
        font-family: inherit;
      }

      .custom-input-container input:focus,
      .custom-input-container textarea:focus {
        outline: none;
        border-color: #0066ff;
      }

      .custom-input-container textarea {
        resize: vertical;
        min-height: 100px;
      }

      .custom-image-preview {
        margin-top: 0.75rem;
      }

      .custom-image-preview img {
        max-width: 150px;
        max-height: 150px;
        border-radius: 8px;
        object-fit: cover;
      }

      .custom-image-tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .tab-btn {
        padding: 0.5rem 1rem;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        color: #888;
        cursor: pointer;
        transition: all 0.2s;
      }

      .tab-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .tab-btn.active {
        background: rgba(0, 102, 255, 0.2);
        border-color: #0066ff;
        color: #0066ff;
      }

      .image-tab-content {
        margin-bottom: 0.5rem;
      }

      .file-upload-area {
        border: 2px dashed rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        color: #888;
      }

      .file-upload-area:hover,
      .file-upload-area.drag-over {
        border-color: #0066ff;
        background: rgba(0, 102, 255, 0.1);
        color: #0066ff;
      }

      .file-upload-area .upload-icon {
        font-size: 2rem;
      }

      .file-upload-area small {
        font-size: 0.75rem;
        opacity: 0.7;
      }

      .error-message {
        display: none;
        text-align: center;
        padding: 2rem;
        background: rgba(239, 68, 68, 0.1);
        border-radius: 12px;
        border: 1px solid rgba(239, 68, 68, 0.3);
        color: #f87171;
      }

      .error-message.active {
        display: block;
      }

      .suggestions {
        margin-top: 2rem;
        text-align: center;
      }

      .suggestions p {
        color: #6b7280;
        font-size: 0.9rem;
        margin-bottom: 1rem;
      }

      .suggestion-chips {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
      }

      .suggestion-chip {
        padding: 0.5rem 1rem;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        font-size: 0.85rem;
        color: #a8a8a8;
        cursor: pointer;
      }

      .suggestion-chip:hover {
        background: rgba(0, 102, 255, 0.2);
        border-color: rgba(0, 102, 255, 0.4);
        color: #00aaff;
      }

      /* Debug panel */
      .debug-panel {
        margin-top: 2rem;
        padding: 1rem;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        font-family: monospace;
        font-size: 0.75rem;
        color: #6b7280;
        max-height: 300px;
        overflow-y: auto;
      }

      .debug-panel h4 {
        color: #00aaff;
        margin-bottom: 0.5rem;
      }

      .debug-entry {
        margin: 0.25rem 0;
        padding: 0.25rem;
        border-left: 2px solid #333;
        padding-left: 0.5rem;
      }

      .debug-entry.success {
        border-color: #22c55e;
      }

      .debug-entry.error {
        border-color: #ef4444;
      }

      @media (max-width: 600px) {
        .search-container {
          flex-direction: column;
        }
        .profile-header {
          flex-direction: column;
          align-items: center;
          text-align: center;
        }
      }

      .still-searching {
        background: linear-gradient(
          90deg,
          rgba(0, 102, 255, 0.1),
          rgba(0, 170, 255, 0.1)
        );
        border: 1px solid rgba(0, 102, 255, 0.3);
        border-radius: 8px;
        padding: 0.75rem 1rem;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        color: #00aaff;
        font-size: 0.9rem;
        animation: pulse-bg 2s ease-in-out infinite;
      }

      @keyframes pulse-bg {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      .searching-spinner {
        width: 16px;
        height: 16px;
        border: 2px solid rgba(0, 170, 255, 0.3);
        border-top-color: #00aaff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <img src="logo.png" alt="LitLyric Logo" class="header-logo" />
        <h1>The LitLyric Narrator Project</h1>
        <p class="subtitle">
          Search multiple sources for audiobook narrator profiles
        </p>
        <span class="version-badge">v2.2.0</span>
      </header>

      <div class="search-container">
        <input
          type="text"
          class="search-input"
          id="narratorInput"
          placeholder="Enter narrator name (e.g., Simon Vance)"
          autocomplete="off"
        />
        <button class="search-btn" id="searchBtn">Search</button>
        <label
          class="fast-mode-toggle"
          title="Skip slower sources (SoundCloud, Soundbooth, etc.)"
        >
          <input type="checkbox" id="fastModeToggle" /> Fast
        </label>
      </div>

      <div class="loading" id="loading">
        <div class="spinner"></div>
        <p>Searching narrator databases...</p>
        <div class="source-progress" id="sourceProgress"></div>
      </div>

      <div class="error-message" id="errorMessage"></div>

      <!-- Existing Narrator Profile (shown when found in database) -->
      <div
        class="existing-profile-card"
        id="existingProfileCard"
        style="display: none"
      >
        <div class="existing-profile-header">
          <div class="existing-profile-image" id="existingProfileImage">
            <img src="" alt="" id="existingImage" />
            <div
              class="no-image-placeholder"
              id="existingNoImage"
              style="display: none"
            >
              <span>No Photo</span>
            </div>
          </div>
          <div class="existing-profile-info">
            <span class="database-badge">‚úì In LitLyric Database</span>
            <h2 id="existingNarratorName"></h2>
          </div>
        </div>

        <div class="existing-profile-bio">
          <h3>About</h3>
          <p id="existingBio"></p>
          <p
            id="existingNoBio"
            style="display: none; color: #6b7280; font-style: italic"
          >
            No biography available.
          </p>
        </div>

        <div class="existing-profile-actions">
          <button class="request-change-btn" onclick="startChangeRequest()">
            ‚úèÔ∏è Request Change
          </button>
          <button class="report-btn" onclick="showReportModal()">
            üö© Report Issue
          </button>
        </div>
      </div>

      <!-- Search Results Card (shown for new narrators or when editing) -->
      <div class="result-card" id="resultCard">
        <div class="still-searching" id="stillSearching" style="display: none">
          <span class="searching-spinner"></span> Still searching for more
          sources...
        </div>
        <div class="profile-header">
          <div class="profile-info-header">
            <h2 class="narrator-name" id="narratorName"></h2>
            <p class="narrator-tagline" id="narratorTagline"></p>
            <div class="source-badges" id="sourceBadges"></div>
          </div>
        </div>

        <!-- Image Selection Section -->
        <div class="selection-section" id="imageSelectionSection">
          <h3>üì∑ Select Profile Image</h3>
          <div class="image-options" id="imageOptions"></div>
          <div
            class="custom-input-container"
            id="customImageInput"
            style="display: none"
          >
            <label>Custom Image:</label>
            <div class="custom-image-tabs">
              <button
                type="button"
                class="tab-btn active"
                onclick="switchImageTab('url')"
              >
                URL
              </button>
              <button
                type="button"
                class="tab-btn"
                onclick="switchImageTab('upload')"
              >
                Upload
              </button>
            </div>
            <div id="imageUrlTab" class="image-tab-content">
              <input
                type="text"
                id="customImageUrl"
                placeholder="https://example.com/image.jpg"
                oninput="updateExportData()"
              />
            </div>
            <div
              id="imageUploadTab"
              class="image-tab-content"
              style="display: none"
            >
              <div
                class="file-upload-area"
                id="fileUploadArea"
                onclick="document.getElementById('imageFileInput').click()"
                ondragover="handleDragOver(event)"
                ondragleave="handleDragLeave(event)"
                ondrop="handleFileDrop(event)"
              >
                <span class="upload-icon">üìÅ</span>
                <span>Click to upload or drag & drop</span>
                <small>JPG, PNG, GIF, WebP</small>
              </div>
              <input
                type="file"
                id="imageFileInput"
                accept="image/*"
                style="display: none"
                onchange="handleFileSelect(event)"
              />
            </div>
            <div class="custom-image-preview" id="customImagePreview"></div>
          </div>
        </div>

        <!-- Bio Selection Section -->
        <div class="selection-section" id="bioSelectionSection">
          <h3>üìù Select Biography</h3>
          <div class="bio-options" id="bioOptions"></div>
          <div
            class="custom-input-container"
            id="customBioInput"
            style="display: none"
          >
            <label>Custom Biography:</label>
            <textarea
              id="customBioText"
              placeholder="Write a custom biography..."
              rows="4"
              oninput="updateExportData()"
            ></textarea>
          </div>

          <!-- AI Bio Generation -->
          <div
            class="ai-bio-section"
            id="aiBioSection"
            style="
              margin-top: 1rem;
              padding-top: 1rem;
              border-top: 1px solid rgba(255, 255, 255, 0.1);
            "
          >
            <button
              class="ai-generate-btn"
              id="aiGenerateBtn"
              onclick="generateAIBio()"
            >
              ‚ú® Generate Bio with AI
            </button>
            <p style="font-size: 0.75rem; color: #6b7280; margin-top: 0.5rem">
              Uses Gemini AI to create a professional narrator bio
            </p>
          </div>
        </div>

        <!--   <div class="profile-body">
               <div class="section" id="awardsSection">
                    <h3>üèÜ Awards</h3>
                    <div class="tags-list" id="awardsList"></div>
                </div>

                <div class="section" id="accentsSection">
                    <h3>üó£Ô∏è Accents</h3>
                    <div class="tags-list" id="accentsList"></div>
                </div>

                <div class="section" id="genresSection">
                    <h3>üé≠ Genres</h3>
                    <div class="tags-list" id="genresList"></div>
                </div>
                
                <div class="section" id="worksSection">
                    <h3>üìö Notable Audiobooks</h3>
                    <div class="tags-list" id="worksList"></div>
                </div>

                <div class="sources-section">
                    <h4>Sources</h4>
                    <div class="sources-list" id="sourcesList"></div>
                </div>
            </div>-->

        <!-- Export Section -->
        <div class="export-section">
          <!-- JSON display hidden for cleaner UI
    <h3>üì§ Selected Data</h3>
    <pre id="exportData"></pre>
    -->
          <pre id="exportData" style="display: none"></pre>

          <!-- Buttons for NEW narrators (not in database) -->
          <div
            id="newNarratorButtons"
            style="
              display: flex;
              flex-wrap: wrap;
              align-items: center;
              justify-content: center;
            "
          >
            <!-- Copy JSON hidden for cleaner UI
        <button class="export-btn" id="copyBtn">Copy JSON</button>
        -->
            <button
              class="firebase-btn"
              id="firebaseBtn"
              onclick="uploadToFirebase()"
            >
              ‚òÅÔ∏è Submit to LitLyric Database
            </button>
          </div>

          <!-- Buttons for EXISTING narrators (already in database) -->
          <div
            id="existingNarratorButtons"
            style="
              display: none;
              flex-wrap: wrap;
              gap: 0.5rem;
              align-items: center;
              justify-content: center;
            "
          >
            <!-- Copy JSON hidden for cleaner UI
    <button class="export-btn" id="copyBtn2" onclick="copyJson()">Copy JSON</button>
    -->
            <button
              class="request-change-btn"
              id="requestChangeBtn"
              onclick="showRequestChangeModal()"
            >
              üì§ Submit Change Request
            </button>
          </div>

          <div class="firebase-status" id="firebaseStatus"></div>
          <p
            style="
              font-size: 0.75rem;
              color: #6b7280;
              margin-top: 0.5rem;
              text-align: center;
            "
          >
            Community database - uploads are shared with all LitLyric users
          </p>
        </div>
      </div>

      <!-- Request Change Modal -->
      <div class="modal-overlay" id="requestChangeModal" style="display: none">
        <div class="modal-content">
          <h3>‚úèÔ∏è Submit Change Request</h3>
          <p>
            Your selected image and bio will be submitted for review. An admin
            will approve the changes before they go live.
          </p>

          <div class="modal-form">
            <label>Reason for change (optional):</label>
            <textarea
              id="changeReason"
              placeholder="e.g., Found a better quality photo, bio has incorrect information, more detailed bio available..."
            ></textarea>

            <label>Your email (optional, for follow-up):</label>
            <input type="email" id="changeEmail" placeholder="your@email.com" />
          </div>

          <div class="modal-buttons">
            <button class="modal-cancel" onclick="closeRequestChangeModal()">
              Cancel
            </button>
            <button class="modal-submit" onclick="submitChangeRequest()">
              Submit for Review
            </button>
          </div>
        </div>
      </div>

      <!-- Report Modal -->
      <div class="modal-overlay" id="reportModal" style="display: none">
        <div class="modal-content">
          <h3>üö© Report Issue</h3>
          <p>Report a problem with this narrator entry.</p>

          <div class="modal-form">
            <label>Reason for report:</label>
            <div class="radio-group">
              <label
                ><input type="radio" name="reportReason" value="wrong_person" />
                Wrong person / Incorrect identity</label
              >
              <label
                ><input
                  type="radio"
                  name="reportReason"
                  value="inappropriate"
                />
                Inappropriate content</label
              >
              <label
                ><input type="radio" name="reportReason" value="copyright" />
                Copyright issue</label
              >
              <label
                ><input type="radio" name="reportReason" value="outdated" />
                Severely outdated information</label
              >
              <label
                ><input type="radio" name="reportReason" value="spam" /> Spam or
                fake entry</label
              >
              <label
                ><input type="radio" name="reportReason" value="other" />
                Other</label
              >
            </div>

            <label>Additional details:</label>
            <textarea
              id="reportDetails"
              placeholder="Please describe the issue..."
            ></textarea>

            <label>Your email (optional, for follow-up):</label>
            <input type="email" id="reportEmail" placeholder="your@email.com" />
          </div>

          <div class="modal-buttons">
            <button class="modal-cancel" onclick="closeReportModal()">
              Cancel
            </button>
            <button class="modal-submit report" onclick="submitReport()">
              Submit Report
            </button>
          </div>
        </div>
      </div>

      <div class="suggestions" id="suggestions">
        <p>Try searching for popular narrators:</p>
        <div class="suggestion-chips">
          <span class="suggestion-chip" data-narrator="Simon Vance"
            >Simon Vance</span
          >
          <span class="suggestion-chip" data-narrator="Jim Dale">Jim Dale</span>
          <span class="suggestion-chip" data-narrator="Scott Brick"
            >Scott Brick</span
          >
          <span class="suggestion-chip" data-narrator="Julia Whelan"
            >Julia Whelan</span
          >
          <span class="suggestion-chip" data-narrator="Ray Porter"
            >Ray Porter</span
          >
          <span class="suggestion-chip" data-narrator="Andrea Parsneau"
            >Andrea Parsneau</span
          >
          <span class="suggestion-chip" data-narrator="Travis Baldree"
            >Travis Baldree</span
          >
          <span class="suggestion-chip" data-narrator="RC Bray">RC Bray</span>
          <span class="suggestion-chip" data-narrator="Stephen Fry"
            >Stephen Fry</span
          >
          <span class="suggestion-chip" data-narrator="Nick Podehl"
            >Nick Podehl</span
          >
        </div>
      </div>

      <!-- <div class="debug-panel" id="debugPanel">
            <h4>Debug Log</h4>
            <div id="debugLog"></div>
        </div>-->
    </div>

    <script>
      // ============================================
      // CLOUDFLARE CDN CONFIGURATION
      // ============================================
      // Set this to your Cloudflare Worker URL after deploying
      // Leave as null to use Firebase Storage directly (higher egress costs)
      const CLOUDFLARE_WORKER_URL =
        "https://still-resonance-ae9e.shane9b3.workers.dev";
      // const CLOUDFLARE_WORKER_URL = null; // Uncomment to disable CDN

      // Helper function to convert Firebase Storage URL to Cloudflare CDN URL
      function getCdnImageUrl(firebaseUrl) {
        // If CDN not configured, return original URL
        if (!CLOUDFLARE_WORKER_URL) {
          return firebaseUrl;
        }

        // If it's already a CDN URL, return as-is
        if (
          firebaseUrl.includes("workers.dev") ||
          firebaseUrl.includes(CLOUDFLARE_WORKER_URL)
        ) {
          return firebaseUrl;
        }

        // If it's not a Firebase Storage URL, return as-is
        if (!firebaseUrl.includes("firebasestorage.googleapis.com")) {
          return firebaseUrl;
        }

        // Extract the path from Firebase Storage URL
        // Firebase URL format: https://firebasestorage.googleapis.com/v0/b/BUCKET/o/PATH?alt=media
        try {
          const url = new URL(firebaseUrl);
          const pathMatch = url.pathname.match(/\/o\/(.+)/);

          if (pathMatch) {
            // Decode the path (it's URL-encoded in Firebase URLs)
            const imagePath = decodeURIComponent(pathMatch[1]);

            // Construct CDN URL
            return `${CLOUDFLARE_WORKER_URL}/${imagePath}`;
          }
        } catch (e) {
          console.warn("Failed to parse Firebase URL:", e);
        }

        return firebaseUrl;
      }

      // Source configurations
      const SOURCES = {
        audible: {
          name: "Audible",
          icon: "üéß",
          getUrl: (name) =>
            `https://www.audible.com/ep/narrator-${nameToSlug(name)}`,
        },
        wikipedia: {
          name: "Wikipedia",
          icon: "üìñ",
          getUrl: (name) =>
            `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(
              name.replace(/ /g, "_")
            )}`,
        },
        audiofile: {
          name: "AudioFile",
          icon: "üì∞",
          getUrl: (name) =>
            `https://www.audiofilemagazine.com/narrators/${nameToSlug(name)}/`,
        },
        voicestoknow: {
          name: "Voices to Know",
          icon: "üé§",
          getUrl: (name) =>
            `https://voicestoknow.com/talent/${nameToSlug(name)}/`,
        },
        soundbooth: {
          name: "Soundbooth",
          icon: "üé≠",
          getUrl: (name) =>
            `https://soundbooththeater.com/team/${nameToSlug(name)}/`,
        },
        soundcloud: {
          name: "SoundCloud",
          icon: "‚òÅÔ∏è",
          getUrl: (name) =>
            `https://soundcloud.com/${name
              .toLowerCase()
              .replace(/[^a-z0-9]/g, "")}`,
        },
        personalsite: {
          name: "Personal Site",
          icon: "üåê",
          getUrl: (name) => null, // Dynamic
        },
        tantor: {
          name: "Tantor",
          icon: "üìö",
          getUrl: (name) =>
            `https://tantor.com/narrator/${nameToSlug(name)}.html`,
        },
        imdb: {
          name: "IMDB",
          icon: "üé¨",
          getUrl: (name) =>
            `https://www.imdb.com/find/?q=${encodeURIComponent(name)}&s=nm`,
        },
        google: {
          name: "Google",
          icon: "üîç",
          getUrl: (name) =>
            `https://www.google.com/search?q=${encodeURIComponent(
              name + " audiobook narrator"
            )}`,
        },
      };

      const searchInput = document.getElementById("narratorInput");
      const searchBtn = document.getElementById("searchBtn");
      const loading = document.getElementById("loading");
      const resultCard = document.getElementById("resultCard");
      const errorMessage = document.getElementById("errorMessage");
      const suggestions = document.getElementById("suggestions");
      const sourceProgress = document.getElementById("sourceProgress");
      const debugLog = document.getElementById("debugLog");

      // Event listeners
      document.querySelectorAll(".suggestion-chip").forEach((chip) => {
        chip.addEventListener("click", () => {
          searchInput.value = chip.dataset.narrator;
          performSearch();
        });
      });

      searchInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") performSearch();
      });

      searchBtn.addEventListener("click", () => performSearch());

      function nameToSlug(name) {
        return name
          .toLowerCase()
          .replace(/[^a-z0-9\s\-]/g, "") // Keep hyphens
          .replace(/\s+/g, "-") // Replace spaces with hyphens
          .replace(/--+/g, "-") // Replace multiple hyphens with single
          .trim();
      }

      // Generate slug variant with periods expanded (RC -> r-c)
      function nameToSlugExpanded(name) {
        return name
          .toLowerCase()
          .split(/\s+/)
          .map((word) => {
            // If word is 2-3 letters and all same case, expand initials
            if (word.length <= 3 && /^[a-z]+$/.test(word)) {
              return word.split("").join("-");
            }
            return word;
          })
          .join("-")
          .replace(/[^a-z0-9\-]/g, "")
          .replace(/--+/g, "-")
          .trim();
      }

      // Helper function to fetch an image URL and convert to base64
      // Helper function to fetch an image URL and convert to base64
async function fetchImageAsBase64(imageUrl) {
    // First try direct fetch (works for CORS-enabled sources)
    try {
        const response = await fetch(imageUrl);
        if (response.ok) {
            const blob = await response.blob();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
    } catch (e) {
        // Direct fetch failed, try proxy
    }

    // Use our proxy - it returns base64 string directly for images
    const result = await fetchViaProxy(imageUrl);
    
    // Check if result is a base64 data URL string
    if (result && typeof result === 'string' && result.startsWith('data:')) {
        return result;
    }

    throw new Error("Failed to fetch image");
}

      function log(message, type = "info") {
        // Debug panel may be hidden/removed - just log to console
        console.log(`[${type.toUpperCase()}] ${message}`);

        if (debugLog) {
          const entry = document.createElement("div");
          entry.className = `debug-entry ${type}`;
          entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
          debugLog.appendChild(entry);
          debugLog.scrollTop = debugLog.scrollHeight;
        }
      }

      function updateSourceStatus(sourceKey, status) {
        const el = document.getElementById(`status-${sourceKey}`);
        if (el) {
          el.className = `source-status ${status}`;
        }
      }

      // REPLACE your fetchViaProxy function with this:

      async function fetchViaProxy(url) {
        // Use YOUR OWN Netlify proxy
        const proxyUrl = `/api/proxy?url=${encodeURIComponent(url)}`;

        try {
          const response = await fetch(proxyUrl);

          // Only treat actual proxy errors as failures (502 = network error)
          if (response.status === 502) {
            throw new Error(`Failed to fetch (502)`);
          }

          // 400 = bad request to proxy
          if (response.status === 400) {
            const errorData = await response.json();
            throw new Error(errorData.error || "Bad request");
          }

          const contentType = response.headers.get("content-type") || "";

          // Check if it's a JSON response (for images or errors)
          if (contentType.includes("application/json")) {
            const json = await response.json();
            // If it's an image response from our proxy
            if (json.base64) {
              // Return the base64 data for image handling
              return json.base64;
            }
            // If it's an error from the proxy
            if (json.error) {
              throw new Error(json.error);
            }
            // Otherwise return JSON as string
            return JSON.stringify(json);
          }

          // Text/HTML response - return the text directly
          // This maintains compatibility with existing search functions
          const text = await response.text();
          return text;
        } catch (error) {
          console.warn(`Proxy failed for ${url}:`, error.message);
          // Return empty string on failure (search functions check length)
          return "";
        }
      }

      // Strip HTML tags
      function stripHtml(html) {
        return html
          .replace(/<[^>]*>/g, "")
          .replace(/&amp;/g, "&")
          .replace(/&lt;/g, "<")
          .replace(/&gt;/g, ">")
          .replace(/&quot;/g, '"')
          .replace(/&#x27;/g, "'")
          .replace(/&nbsp;/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      // Clean bio text - remove narrator name from the start if present
      function cleanBio(bio, name) {
        if (!bio || !name) return bio;

        let cleanedBio = bio.trim();

        // Create variants of the name to check
        const nameVariants = [
          name,
          name.replace(/\./g, ""), // Remove periods (R.C. -> RC)
          name.replace(/\s+/g, " ").trim(), // Normalize spaces
        ];

        for (const nameVariant of nameVariants) {
          // Only remove name if it's followed by punctuation that indicates a header/title
          // NOT if it's followed by "is", "was", "has" etc. (part of a sentence)
          const escapedName = nameVariant.replace(
            /[.*+?^${}()|[\]\\]/g,
            "\\$&"
          );

          // Pattern: Name followed by comma, colon, semicolon, or dash (header style)
          // But NOT followed by " is", " was", " has", " grew" etc. (sentence style)
          const headerRegex = new RegExp(`^${escapedName}[,:;‚Äî‚Äì-]\\s*`, "i");

          if (headerRegex.test(cleanedBio)) {
            cleanedBio = cleanedBio.replace(headerRegex, "").trim();
            // Capitalize first letter after removing name
            if (cleanedBio.length > 0) {
              cleanedBio =
                cleanedBio.charAt(0).toUpperCase() + cleanedBio.slice(1);
            }
            break;
          }
        }

        return cleanedBio;
      }

      // Search Audible
      async function searchAudible(name) {
        // Try the narrator search page instead of /ep/narrator which seems deprecated
        const searchUrl = `https://www.audible.com/search?searchNarrator=${encodeURIComponent(
          name
        )}`;
        log(`Audible: Fetching ${searchUrl}`);

        try {
          const html = await fetchViaProxy(searchUrl);

          if (html.length < 5000) {
            log("Audible: Page not found or empty", "error");
            return null;
          }

          const result = {
            source: "audible",
            url: searchUrl,
            name: null,
            imageUrl: null,
            tagline: null,
            bio: null,
            books: [],
            awards: [],
          };

          // The search results page shows books narrated by this person
          // Extract book titles from the results
          const bookMatches = html.matchAll(
            /title['"]\s*:\s*['"]((?:[^'"\\]|\\.)*)['"]|class="bc-heading[^"]*"[^>]*>([^<]+)</gi
          );
          for (const match of bookMatches) {
            const title = stripHtml(match[1] || match[2] || "").trim();
            if (
              title &&
              title.length > 3 &&
              title.length < 100 &&
              !title.includes("Audible") &&
              !title.includes("Sign") &&
              !result.books.includes(title) &&
              result.books.length < 15
            ) {
              result.books.push(title);
            }
          }

          // Set the narrator name
          result.name = name;

          log(`Audible: Found ${result.books.length} books`);

          // Audible search pages don't have narrator images, so we won't get one here
          // But we still return the result for the books list

          if (result.books.length > 0) {
            return result;
          }

          log("Audible: No results found", "error");
          return null;
        } catch (error) {
          log(`Audible: Error - ${error.message}`, "error");
          return null;
        }
      }

      // Search Wikipedia
      async function searchWikipedia(name) {
        // Capitalize each word for Wikipedia (Wikipedia URLs are case-sensitive)
        const capitalizedName = name
          .split(/\s+/)
          .map(
            (word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
          )
          .join("_");

        // Create a version with periods and spaces for initials (RC -> R. C.)
        const nameWithPeriods = name
          .split(/\s+/)
          .map((word) => {
            // If word is 2-3 uppercase letters (initials), add periods and spaces
            if (
              word.length <= 3 &&
              /^[A-Za-z]+$/.test(word) &&
              word.toUpperCase() === word
            ) {
              // RC -> R. C.
              return word.toUpperCase().split("").join(". ").trim() + ".";
            }
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
          })
          .join("_");

        // Try narrator/actor variants FIRST, then general name
        const variants = [
          capitalizedName + "_(voice_actor)",
          capitalizedName + "_(narrator)",
          capitalizedName + "_(actor)",
          nameWithPeriods + "_(voice_actor)",
          nameWithPeriods + "_(narrator)",
          nameWithPeriods + "_(actor)",
          capitalizedName, // Try general name last
          nameWithPeriods,
        ];

        // Remove duplicates
        const uniqueVariants = [...new Set(variants)];

        for (const variant of uniqueVariants) {
          const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(
            variant
          )}`;
          log(`Wikipedia: Fetching ${url}`);

          try {
            const response = await fetch(url);
            if (!response.ok) {
              continue; // Try next variant
            }

            const data = await response.json();

            if (data.type === "disambiguation" || data.type === "not_found") {
              continue; // Try next variant
            }

            // Check if this Wikipedia article is about a narrator/voice actor
            const bio = (data.extract || "").toLowerCase();
            const isNarrator =
              bio.includes("narrator") ||
              bio.includes("voice actor") ||
              bio.includes("voice-over") ||
              bio.includes("voiceover") ||
              bio.includes("audiobook") ||
              bio.includes("audio book") ||
              bio.includes("voice artist");

            const isActor = bio.includes("actor") || bio.includes("actress");
            const isAuthor = bio.includes("author") || bio.includes("writer");

            // Accept if they're an actor, narrator, or author (many authors narrate their own books)
            const isLikelyNarrator = isNarrator || isActor || isAuthor;

            // Only filter out people who are DEFINITELY not narrators
            const isDefinitelyNotNarrator =
              !isLikelyNarrator &&
              // Sports
              (bio.includes("football player") ||
                bio.includes("basketball player") ||
                bio.includes("baseball player") ||
                bio.includes("soccer player") ||
                bio.includes("hockey player") ||
                bio.includes("professional athlete") ||
                // Politics
                bio.includes("politician") ||
                bio.includes("senator") ||
                bio.includes("congressman") ||
                bio.includes("governor") ||
                // Other clearly non-narrator professions
                bio.includes("serial killer") ||
                bio.includes("murderer"));

            if (isDefinitelyNotNarrator) {
              log(
                `Wikipedia: Found "${data.title}" but appears to be wrong person, trying next variant...`
              );
              continue; // Try next variant
            }

            const result = {
              source: "wikipedia",
              url: data.content_urls?.desktop?.page || url,
              name: data.title,
              bio: data.extract,
              imageUrl: null,
              images: [],
            };

            // Collect multiple image sizes from Wikipedia
            if (data.originalimage?.source) {
              result.images.push(data.originalimage.source);
              result.imageUrl = data.originalimage.source;
            }
            if (data.thumbnail?.source) {
              // Get larger versions
              const thumb = data.thumbnail.source;
              const large = thumb.replace(/\/\d+px-/, "/400px-");
              const medium = thumb.replace(/\/\d+px-/, "/300px-");
              if (!result.images.includes(large)) result.images.push(large);
              if (!result.images.includes(medium)) result.images.push(medium);
              if (!result.imageUrl) result.imageUrl = large;
            }

            log(
              `Wikipedia: Found! "${data.title}" - Bio: ${
                result.bio?.length || 0
              } chars, Images: ${result.images.length}`
            );
            return result;
          } catch (error) {
            log(
              `Wikipedia: Error with variant ${variant} - ${error.message}`,
              "error"
            );
            continue;
          }
        }

        log("Wikipedia: Not found (tried all variants)", "error");
        return null;
      }

      // Search AudioFile Magazine
      async function searchAudioFile(name) {
        // Try the normal slug first, then expanded slug for initials
        const urls = [
          SOURCES.audiofile.getUrl(name),
          `https://www.audiofilemagazine.com/narrators/${nameToSlugExpanded(
            name
          )}/`,
        ];

        // Remove duplicates
        const uniqueUrls = [...new Set(urls)];

        for (const url of uniqueUrls) {
          log(`AudioFile: Fetching ${url}`);

          try {
            const html = await fetchViaProxy(url);

            // Better detection - check for actual narrator content
            const hasNarratorContent =
              html.includes("Spotlight on") ||
              html.includes("Recent audiobooks") ||
              html.includes("Talking with") ||
              html.includes("/narrators/");

            if (!hasNarratorContent || html.length < 2000) {
              log(`AudioFile: No narrator content at ${url}`, "error");
              continue; // Try next URL
            }

            const result = {
              source: "audiofile",
              url: url,
              imageUrl: null,
              bio: null,
              accents: [],
              genres: [],
              awards: [],
            };

            // Extract narrator image
            // Pattern: /images/400x400/content/uploaded/images/narrators/name.jpg
            // or /content/uploaded/images/narrators/name.jpg
            const imgPatterns = [
              /src="(https?:\/\/[^"]*\/images\/\d+x\d+\/content\/uploaded\/images\/narrators\/[^"]+\.(?:jpg|jpeg|png))"/i,
              /src="([^"]*\/content\/uploaded\/images\/narrators\/[^"]+\.(?:jpg|jpeg|png))"/i,
              /src="([^"]*narrators\/[^"]+\.(?:jpg|jpeg|png))"/i,
            ];

            for (const pattern of imgPatterns) {
              const match = html.match(pattern);
              if (match) {
                let imgUrl = match[1];
                // Make sure it's a full URL
                if (!imgUrl.startsWith("http")) {
                  imgUrl =
                    "https://www.audiofilemagazine.com" +
                    (imgUrl.startsWith("/") ? "" : "/") +
                    imgUrl;
                }
                // Skip small icons (200x200 are usually icons, not main photos)
                if (!imgUrl.includes("200x200") && !imgUrl.includes("icon")) {
                  result.imageUrl = imgUrl;
                  log(`AudioFile: Found image`);
                  break;
                }
              }
            }

            // Extract accents
            const accentsMatch = html.match(/Accents?:\s*([^¬∑<\n]+)/i);
            if (accentsMatch) {
              result.accents = accentsMatch[1]
                .split(",")
                .map((a) => a.trim())
                .filter((a) => a);
              log(`AudioFile: Found ${result.accents.length} accents`);
            }

            // Extract genres
            const genresMatch = html.match(/Genres?:\s*([^¬∑<\n]+)/i);
            if (genresMatch) {
              result.genres = genresMatch[1]
                .split(",")
                .map((g) => g.trim())
                .filter((g) => g);
              log(`AudioFile: Found ${result.genres.length} genres`);
            }

            // Extract awards from accolades section
            const awardsMatches = html.matchAll(
              /(Audies? Award[^<*]*|AudioFile Best of \d+[^<*]*|Earphones Award[^<*]*)/gi
            );
            for (const match of awardsMatches) {
              const award = match[1].trim();
              if (
                award &&
                !result.awards.includes(award) &&
                result.awards.length < 10
              ) {
                result.awards.push(award);
              }
            }

            if (
              html.includes("Golden Voice") &&
              !result.awards.some((a) => a.includes("Golden"))
            ) {
              result.awards.push("AudioFile Golden Voice");
            }
            log(`AudioFile: Found ${result.awards.length} awards`);

            // Extract bio from "Talking with" section
            const talkingWithMatch = html.match(
              /Talking with[^<]*<\/h3>([\s\S]*?)(?:<h3|Read More|Photo courtesy)/i
            );
            if (talkingWithMatch) {
              // Get paragraphs from the section
              const section = talkingWithMatch[1];
              const paragraphs = section.match(/<p[^>]*>([\s\S]*?)<\/p>/gi);
              if (paragraphs && paragraphs.length > 0) {
                // Get first 2-3 paragraphs
                const bioText = paragraphs
                  .slice(0, 3)
                  .map((p) => stripHtml(p))
                  .filter((p) => p.length > 50)
                  .join(" ");
                if (bioText.length > 100) {
                  result.bio = bioText;
                  log(`AudioFile: Found bio (${result.bio.length} chars)`);
                }
              }
            }

            return result;
          } catch (error) {
            log(`AudioFile: Error trying ${url} - ${error.message}`, "error");
            continue; // Try next URL
          }
        }

        log("AudioFile: Page not found", "error");
        return null;
      }

      // Search Soundbooth Theater
      async function searchSoundbooth(name) {
        const url = SOURCES.soundbooth.getUrl(name);
        log(`Soundbooth: Fetching ${url}`);

        try {
          const html = await fetchViaProxy(url);

          // Check if page exists
          if (
            html.includes("Page not found") ||
            html.includes("404") ||
            html.length < 2000
          ) {
            log("Soundbooth: Page not found", "error");
            return null;
          }

          const result = {
            source: "soundbooth",
            url: url,
            name: null,
            imageUrl: null,
            bio: null,
            books: [],
          };

          // Extract name from h1
          const nameMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
          if (nameMatch) {
            result.name = stripHtml(nameMatch[1]);
            log(`Soundbooth: Found name "${result.name}"`);
          }

          // Extract profile image - they use wp-content/uploads
          const imgMatch = html.match(
            /src="(https:\/\/soundbooththeater\.com\/wp-content\/uploads\/[^"]+(?:jpg|jpeg|png)[^"]*)"/i
          );
          if (imgMatch) {
            result.imageUrl = imgMatch[1];
            log(`Soundbooth: Found image`);
          }

          // Alternative image pattern - look for team member images
          if (!result.imageUrl) {
            const altImgMatch = html.match(
              /uploads\/\d+\/\d+\/[^"]*(?:jpg|jpeg|png)/i
            );
            if (altImgMatch) {
              result.imageUrl = `https://soundbooththeater.com/wp-content/${altImgMatch[0]}`;
              log(`Soundbooth: Found image (alt pattern)`);
            }
          }

          // Extract bio - usually in paragraphs after the title
          const bioMatch = html.match(
            /<h3[^>]*>Narrator<\/h3>[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i
          );
          if (bioMatch) {
            result.bio = stripHtml(bioMatch[1]);
            log(`Soundbooth: Found bio (${result.bio.length} chars)`);
          }

          // Alternative bio extraction
          if (!result.bio) {
            const altBioMatch = html.match(
              /is an? (?:actor|narrator|voice)[^<]{50,800}/i
            );
            if (altBioMatch) {
              result.bio = stripHtml(altBioMatch[0]);
              log(
                `Soundbooth: Found bio (alt pattern, ${result.bio.length} chars)`
              );
            }
          }

          // Extract audiobook titles
          const bookMatches = html.matchAll(/<h6[^>]*>([^<]+)<\/h6>/gi);
          for (const match of bookMatches) {
            const title = stripHtml(match[1]);
            if (
              title.length > 3 &&
              !result.books.includes(title) &&
              result.books.length < 10
            ) {
              result.books.push(title);
            }
          }
          log(`Soundbooth: Found ${result.books.length} books`);

          return result;
        } catch (error) {
          log(`Soundbooth: Error - ${error.message}`, "error");
          return null;
        }
      }

      // Search Voices to Know
      async function searchVoicesToKnow(name) {
        const url = SOURCES.voicestoknow.getUrl(name);
        log(`Voices to Know: Fetching ${url}`);

        try {
          const html = await fetchViaProxy(url);

          // Check if page exists - look for narrator name in h1 or title
          // Don't just check for generic "not found" since the page might have that text elsewhere
          const hasNarratorContent =
            html.includes("<h1") &&
            (html.includes("Photo courtesy") ||
              html.includes("Recent Audiobooks") ||
              html.includes("Full Audiography"));

          if (!hasNarratorContent || html.length < 5000) {
            log("Voices to Know: Page not found", "error");
            return null;
          }

          const result = {
            source: "voicestoknow",
            url: url,
            name: null,
            imageUrl: null,
            tagline: null,
            bio: null,
            books: [],
            awards: [],
          };

          // Extract name from h1
          const nameMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
          if (nameMatch) {
            result.name = stripHtml(nameMatch[1]);
            log(`Voices to Know: Found name "${result.name}"`);
          }

          // Extract profile image - look for wp-content/uploads images
          // Pattern: https://voicestoknow.com/wp-content/uploads/...jpg
          const imgPatterns = [
            /src="(https:\/\/voicestoknow\.com\/wp-content\/uploads\/[^"]+\.(?:jpg|jpeg|png))"/i,
            /!\[([^\]]*)\]\((https:\/\/voicestoknow\.com\/wp-content\/uploads\/[^)]+\.(?:jpg|jpeg|png))\)/i,
            /"(https:\/\/voicestoknow\.com\/wp-content\/uploads\/\d+\/\d+\/[^"]+\.(?:jpg|jpeg|png))"/i,
          ];

          for (const pattern of imgPatterns) {
            const match = html.match(pattern);
            if (match) {
              // Get the URL (might be in different capture groups)
              const imgUrl = match[2] || match[1];
              // Skip logos, icons, and cover images
              if (
                !imgUrl.includes("Logo") &&
                !imgUrl.includes("logo") &&
                !imgUrl.includes("icon") &&
                !imgUrl.includes("/covers/")
              ) {
                result.imageUrl = imgUrl;
                log(`Voices to Know: Found image`);
                break;
              }
            }
          }

          // Extract tagline (the quote under the name - usually in italics or a specific class)
          // Look for actual quote content, not HTML attributes
          const taglinePatterns = [
            /<em[^>]*>"([^"<]{10,150})"<\/em>/i,
            /<blockquote[^>]*>([^<]{10,150})<\/blockquote>/i,
            /<p[^>]*class="[^"]*quote[^"]*"[^>]*>([^<]{10,150})<\/p>/i,
            />[""]([^""<]{10,150})[""]</i,
          ];

          for (const pattern of taglinePatterns) {
            const match = html.match(pattern);
            if (
              match &&
              !match[1].includes("Voices To Know") &&
              !match[1].includes("itemtype")
            ) {
              result.tagline = stripHtml(match[1]).trim();
              log(`Voices to Know: Found tagline`);
              break;
            }
          }

          // Extract bio from "Talking with" or "About" section
          const bioMatch =
            html.match(
              /Talking with[^<]*<\/h3>[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i
            ) || html.match(/About[^<]*<\/h2>[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i);
          if (bioMatch) {
            result.bio = stripHtml(bioMatch[1]);
            log(`Voices to Know: Found bio (${result.bio.length} chars)`);
          }

          // Extract awards/accolades
          const accoladesSection = html.match(
            /Accolades[\s\S]*?(?=##|<\/section)/i
          );
          if (accoladesSection) {
            // Look for award mentions
            const awardMatches = accoladesSection[0].matchAll(
              /(AudioFile Best of \d+[^<]*|Audie Award[^<]*)/gi
            );
            for (const match of awardMatches) {
              const award = stripHtml(match[1]);
              if (!result.awards.includes(award) && result.awards.length < 10) {
                result.awards.push(award);
              }
            }
            log(`Voices to Know: Found ${result.awards.length} awards`);
          }

          // Extract recent audiobooks
          const booksSection = html.match(
            /Recent Audiobooks[\s\S]*?(?=##|Want to see more)/i
          );
          if (booksSection) {
            const bookMatches = booksSection[0].matchAll(/title="([^"]+)"/gi);
            for (const match of bookMatches) {
              const title = stripHtml(match[1]);
              if (
                title.length > 3 &&
                !result.books.includes(title) &&
                result.books.length < 10
              ) {
                result.books.push(title);
              }
            }
            log(`Voices to Know: Found ${result.books.length} books`);
          }

          return result;
        } catch (error) {
          log(`Voices to Know: Error - ${error.message}`, "error");
          return null;
        }
      }

      // Search Tantor
      async function searchTantor(name) {
        const url = SOURCES.tantor.getUrl(name);
        log(`Tantor: Fetching ${url}`);

        try {
          const html = await fetchViaProxy(url);

          if (
            html.includes("Page Not Found") ||
            html.includes("404") ||
            html.length < 1000
          ) {
            log("Tantor: Page not found", "error");
            return null;
          }

          const result = {
            source: "tantor",
            url: url,
            name: null,
            imageUrl: null,
            bio: null,
            books: [],
          };

          // Extract narrator name from page title or h1
          const nameMatch =
            html.match(/<h1[^>]*>([^<]+)<\/h1>/i) ||
            html.match(/<title>\s*Tantor Media\s*-\s*([^<|]+)/i);
          if (nameMatch) {
            result.name = stripHtml(nameMatch[1]).trim();
            log(`Tantor: Found name "${result.name}"`);
          }

          // IMPORTANT: Verify this is the right person
          // Check if the found name matches what we searched for
          if (result.name) {
            const searchNameLower = name.toLowerCase().replace(/[^a-z]/g, "");
            const foundNameLower = result.name
              .toLowerCase()
              .replace(/[^a-z]/g, "");

            // Check for reasonable name match
            const searchParts = name.toLowerCase().split(/\s+/);
            const foundParts = result.name.toLowerCase().split(/\s+/);

            const lastNameSearch = searchParts[searchParts.length - 1];
            const lastNameFound = foundParts[foundParts.length - 1];

            if (
              !lastNameFound ||
              !lastNameSearch ||
              (!lastNameFound.includes(lastNameSearch) &&
                !lastNameSearch.includes(lastNameFound))
            ) {
              log(
                `Tantor: Name mismatch - searched "${name}" but found "${result.name}", skipping`,
                "error"
              );
              return null;
            }
          } else {
            // No name found - this is probably not the right page
            log("Tantor: Could not verify narrator name, skipping", "error");
            return null;
          }

          // Extract profile image
          const imgPatterns = [
            /src="(https:\/\/tantor[^"]+\.(?:jpg|jpeg|png))"/i,
            /src="([^"]*narrator[^"]*\.(?:jpg|jpeg|png))"/i,
            /src="(https?:\/\/[^"]+\/images\/narrators\/[^"]+\.(?:jpg|jpeg|png))"/i,
          ];

          for (const pattern of imgPatterns) {
            const match = html.match(pattern);
            if (
              match &&
              !match[1].includes("logo") &&
              !match[1].includes("icon")
            ) {
              result.imageUrl = match[1];
              if (!result.imageUrl.startsWith("http")) {
                result.imageUrl = "https://tantor.com" + result.imageUrl;
              }
              log(`Tantor: Found image`);
              break;
            }
          }

          // Extract bio - look for paragraph with narrator keywords
          // First, try to find the bio in common container patterns
          let bioFound = false;

          // Pattern 1: Look for dedicated bio/about sections
          const sectionPatterns = [
            /<div[^>]*class="[^"]*(?:narrator-bio|narrator-about|bio-text|about-text|description)[^"]*"[^>]*>([\s\S]*?)<\/div>/i,
            /<section[^>]*class="[^"]*(?:bio|about)[^"]*"[^>]*>([\s\S]*?)<\/section>/i,
          ];

          for (const pattern of sectionPatterns) {
            const match = html.match(pattern);
            if (match) {
              const text = stripHtml(match[1]).trim();
              if (text.length > 80 && !text.includes("¬ª")) {
                result.bio = cleanBio(text, result.name || name);
                log(
                  `Tantor: Found bio in section (${result.bio.length} chars)`
                );
                bioFound = true;
                break;
              }
            }
          }

          // Pattern 2: Find all paragraphs and look for the best bio candidate
          if (!bioFound) {
            const paragraphRegex = /<p[^>]*>([\s\S]*?)<\/p>/gi;
            let bestBio = null;
            let bestScore = 0;

            let match;
            while ((match = paragraphRegex.exec(html)) !== null) {
              const text = stripHtml(match[1]).trim();

              // Skip if too short or contains navigation indicators
              if (text.length < 80) continue;
              if (
                text.includes("¬ª") ||
                text.includes("BESTSELLER") ||
                text.includes("BARGAIN") ||
                text.includes("Add to Cart") ||
                text.includes("Sign In") ||
                text.includes("Shopping Cart")
              )
                continue;

              // Score the paragraph
              let score = 0;

              // Positive indicators (bio-like content)
              if (/\b(narrator|narrates|narrated|narrating)\b/i.test(text))
                score += 30;
              if (/\b(audiobook|audio book)\b/i.test(text)) score += 25;
              if (/\b(voice actor|voice-over|voiceover)\b/i.test(text))
                score += 25;
              if (/\b(Audie|Earphones|AudioFile)\b/i.test(text)) score += 20;
              if (/\b(award|awards|winner|winning)\b/i.test(text)) score += 15;
              if (
                /\b(actor|actress|acting|stage|theater|theatre|Broadway)\b/i.test(
                  text
                )
              )
                score += 15;
              if (
                /\b(graduate|graduated|BA|MFA|college|university|degree)\b/i.test(
                  text
                )
              )
                score += 15;
              if (/\b(born|raised|grew up)\b/i.test(text)) score += 10;
              if (/\b(she |he |her |his |they )\b/i.test(text)) score += 10;

              // Length bonus (longer is usually better for bios)
              if (text.length > 200) score += 20;
              if (text.length > 400) score += 20;

              // Check if this is the best candidate
              if (score > bestScore && score >= 20) {
                bestScore = score;
                bestBio = text;
              }
            }

            if (bestBio) {
              result.bio = cleanBio(bestBio, result.name || name);
              log(
                `Tantor: Found bio (${result.bio.length} chars, score: ${bestScore})`
              );
            }
          }

          // Extract book titles
          const bookMatches = html.matchAll(
            /title['"]\s*:\s*['"]([^'"]+)['"]/gi
          );
          for (const match of bookMatches) {
            const title = stripHtml(match[1]).trim();
            if (
              title.length > 3 &&
              !result.books.includes(title) &&
              result.books.length < 10
            ) {
              result.books.push(title);
            }
          }
          if (result.books.length > 0) {
            log(`Tantor: Found ${result.books.length} books`);
          }

          return result;
        } catch (error) {
          log(`Tantor: Error - ${error.message}`, "error");
          return null;
        }
      }

      // Search SoundCloud
      async function searchSoundCloud(name) {
        // Try multiple username formats
        const nameLower = name.toLowerCase();
        const nameParts = nameLower.split(/\s+/);
        const firstName = nameParts[0] || "";
        const lastName = nameParts[nameParts.length - 1] || "";
        const middleName =
          nameParts.length > 2 ? nameParts.slice(1, -1).join("") : "";

        const usernameVariants = [
          // First-Last (most common for personal accounts)
          `${firstName}-${lastName}`,
          `${firstName}${lastName}`,
          `${firstName}_${lastName}`,
          // Full name variations
          nameLower.replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, ""),
          nameLower.replace(/\s+/g, "").replace(/[^a-z0-9]/g, ""),
          nameLower.replace(/\s+/g, "_").replace(/[^a-z0-9_]/g, ""),
          // Last name only
          lastName,
          // First + middle + last (no separators)
          `${firstName}${middleName}${lastName}`,
        ].filter((v) => v && v.length > 2);

        // Remove duplicates
        const uniqueVariants = [...new Set(usernameVariants)];

        for (const username of uniqueVariants) {
          const url = `https://soundcloud.com/${username}`;
          log(`SoundCloud: Trying ${url}`);

          try {
            const html = await fetchViaProxy(url);

            log(`SoundCloud: Response length: ${html.length}`);

            // Check if profile exists - SoundCloud error pages are typically shorter
            // and contain specific error messages
            const isErrorPage =
              html.includes("We can't find that user") ||
              html.includes("Something went wrong") ||
              html.includes("This user has been suspended") ||
              html.includes("Page not found") ||
              html.length < 1000;

            if (isErrorPage) {
              log(`SoundCloud: Profile not found at ${username}`);
              continue; // Try next variant
            }

            // Check if this looks like a valid SoundCloud page with actual content
            const hasSoundCloudContent =
              html.includes("sndcdn.com") ||
              html.includes("soundcloud.com") ||
              html.includes("sc-classic");

            // Look for avatar image first - this is the best indicator of a real profile
            const hasAvatar =
              html.includes("avatars-") || html.includes("avatar_url");

            if (!hasSoundCloudContent && !hasAvatar) {
              log(`SoundCloud: No SoundCloud content at ${username}`);
              continue;
            }

            log(`SoundCloud: Valid page found for ${username}`);

            const result = {
              source: "soundcloud",
              url: url,
              name: null,
              imageUrl: null,
              bio: null,
            };

            // Extract profile name from title or h1
            const nameMatch =
              html.match(/<title>([^|<-]+)/i) ||
              html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
            if (nameMatch) {
              result.name = stripHtml(nameMatch[1]).trim();
              log(`SoundCloud: Found name "${result.name}"`);
            }

            // Extract avatar image - SoundCloud uses sndcdn.com for images
            // Try multiple patterns
            const imgPatterns = [
              /avatars-[^"'\s]+\.jpg/gi,
              /(https:\/\/i1\.sndcdn\.com\/avatars-[^"'\s]+)/gi,
              /"avatar_url"\s*:\s*"([^"]+)"/i,
              /avatars[^"']*-t(?:1080x1080|500x500|200x200|large|original)[^"']*\.jpg/gi,
            ];

            for (const pattern of imgPatterns) {
              const imgMatch = html.match(pattern);
              if (imgMatch) {
                let imgUrl = imgMatch[1] || imgMatch[0];
                if (!imgUrl.startsWith("http")) {
                  imgUrl = "https://i1.sndcdn.com/" + imgUrl;
                }
                // Upgrade to larger size
                imgUrl = imgUrl
                  .replace(/-t\d+x\d+/, "-t500x500")
                  .replace(/-large/, "-t500x500")
                  .replace(/-original/, "-t500x500");
                result.imageUrl = imgUrl;
                log(`SoundCloud: Found image: ${imgUrl.substring(0, 60)}...`);
                break;
              }
            }

            // Extract bio/description
            const bioMatch = html.match(
              /(?:description|bio)[^>]*>([^<]{20,500})/i
            );
            if (bioMatch) {
              result.bio = stripHtml(bioMatch[1]);
              log(`SoundCloud: Found bio (${result.bio.length} chars)`);
            }

            if (result.imageUrl || result.bio) {
              return result;
            }
          } catch (error) {
            continue; // Try next variant
          }
        }

        log("SoundCloud: Profile not found", "error");
        return null;
      }

      // Search for personal website
      async function searchPersonalSite(name) {
        const nameLower = name.toLowerCase();
        const nameParts = nameLower.split(/\s+/);
        const firstName = nameParts[0] || "";
        const lastName = nameParts[nameParts.length - 1] || "";
        const fullNameNoSpaces = nameLower.replace(/\s+/g, "");

        // Common personal website domain patterns
        const domainVariants = [
          `${fullNameNoSpaces}.com`, // jamesdanielburkdoll.com
          `www.${fullNameNoSpaces}.com`, // www.jamesdanielburkdoll.com
          `${firstName}${lastName}.com`, // jamesburkdoll.com
          `www.${firstName}${lastName}.com`,
          `${firstName}-${lastName}.com`,
          `www.${firstName}-${lastName}.com`,
        ];

        const uniqueDomains = [...new Set(domainVariants)];

        for (const domain of uniqueDomains) {
          const url = `https://${domain}`;
          log(`Personal Site: Trying ${url}`);

          try {
            const html = await fetchViaProxy(url);
            log(`Personal Site: Response length: ${html.length}`);

            // Check if it's a real page (not a parked domain or error)
            if (
              html.length < 2000 ||
              html.includes("domain is for sale") ||
              html.includes("buy this domain") ||
              html.includes("parked") ||
              html.includes("Page Not Found") ||
              html.includes("404 Not Found")
            ) {
              log(`Personal Site: Invalid page for ${domain}`);
              continue;
            }

            log(`Personal Site: Valid page found at ${domain}`);

            const result = {
              source: "personalsite",
              url: url,
              name: name,
              imageUrl: null,
              images: [],
              bio: null,
            };

            const foundImages = new Set();
            const maxImages = 5;

            // Look for ANY jpg/png image that's likely a profile photo
            const imgPatterns = [
              // Images with profile-like keywords in src or alt
              /<img[^>]+src=["']([^"']+\.(?:jpg|jpeg|png|webp)[^"']*)["'][^>]*(?:alt=["'][^"']*(?:james|burkdoll|headshot|profile|author|narrator)[^"']*["'])?/gi,
              // Any reasonably-sized image
              /<img[^>]+src=["']([^"']+\.(?:jpg|jpeg|png|webp))["']/gi,
              // Background images
              /background(?:-image)?:\s*url\(['"]?([^'")\s]+\.(?:jpg|jpeg|png|webp))['"]?\)/gi,
              // Open Graph image
              /<meta[^>]+property=["']og:image["'][^>]+content=["']([^"']+)["']/gi,
            ];

            for (const pattern of imgPatterns) {
              if (result.images.length >= maxImages) break;

              const matches = html.matchAll(pattern);
              for (const match of matches) {
                if (result.images.length >= maxImages) break;

                let imgUrl = match[1];
                if (!imgUrl) continue;

                // Skip icons, logos, tiny images
                if (
                  imgUrl.includes("icon") ||
                  imgUrl.includes("logo") ||
                  imgUrl.includes("button") ||
                  imgUrl.includes("favicon") ||
                  imgUrl.includes("sprite") ||
                  imgUrl.includes("1x1") ||
                  imgUrl.includes("pixel")
                ) {
                  continue;
                }

                if (!imgUrl.startsWith("http")) {
                  imgUrl = new URL(imgUrl, url).href;
                }

                if (!foundImages.has(imgUrl)) {
                  foundImages.add(imgUrl);
                  result.images.push(imgUrl);
                  if (!result.imageUrl) {
                    result.imageUrl = imgUrl;
                    log(
                      `Personal Site: Found image: ${imgUrl.substring(
                        0,
                        60
                      )}...`
                    );
                  }
                }
              }
            }

            if (result.images.length > 1) {
              log(`Personal Site: Found ${result.images.length} images total`);
            }

            // Look for bio/about text on homepage
            let bioPatterns = [
              /<(?:p|div)[^>]*(?:class|id)=["'][^"']*(?:bio|about|description)[^"']*["'][^>]*>([^<]{50,500})/gi,
              /<meta[^>]+name=["']description["'][^>]+content=["']([^"]{50,300})["']/gi,
            ];

            for (const pattern of bioPatterns) {
              const match = html.match(pattern);
              if (match && match[1]) {
                result.bio = stripHtml(match[1]).trim();
                log(
                  `Personal Site: Found bio on homepage (${result.bio.length} chars)`
                );
                break;
              }
            }

            // Always try about page if we haven't found a good bio yet
            if (!result.bio || result.bio.length < 100) {
              const aboutPages = [
                "/about",
                "/bio",
                "/about-me",
                "/about/",
                "/bio/",
                "/about-me/",
              ];

              for (const aboutPath of aboutPages) {
                try {
                  const aboutUrl = `https://${domain}${aboutPath}`;
                  log(`Personal Site: Checking about page ${aboutUrl}`);
                  const aboutHtml = await fetchViaProxy(aboutUrl);

                  // Better 404 detection
                  if (
                    aboutHtml.length < 1000 ||
                    aboutHtml.includes("Page Not Found") ||
                    aboutHtml.includes("page you were looking for") ||
                    aboutHtml.includes("couldn't find the page") ||
                    aboutHtml.includes("can't find the page") ||
                    aboutHtml.includes("404 Not Found") ||
                    aboutHtml.includes("Error 404")
                  ) {
                    log(
                      `Personal Site: ${aboutPath} appears to be a 404 page, skipping`
                    );
                    continue;
                  }

                  log(
                    `Personal Site: About page found, length: ${aboutHtml.length}`
                  );

                  // Extract paragraphs from about page - look for substantial text
                  // Match p tags with any content inside (including nested HTML)
                  const paragraphMatches = aboutHtml.matchAll(
                    /<p[^>]*>([\s\S]*?)<\/p>/gi
                  );
                  const paragraphs = [];
                  for (const match of paragraphMatches) {
                    const text = stripHtml(match[1]).trim();
                    // Skip navigation, footer text, CSS, JS, and error messages
                    if (
                      text.length > 50 &&
                      !text.toLowerCase().includes("cookie") &&
                      !text.toLowerCase().includes("privacy policy") &&
                      !text.toLowerCase().includes("copyright") &&
                      !text.includes("¬©") &&
                      !text.toLowerCase().includes("subscribe") &&
                      !text.toLowerCase().includes("sign up") &&
                      !text.includes("@supports") &&
                      !text.includes("@media") &&
                      !text.includes("backdrop-filter") &&
                      !text.includes("{") &&
                      !text.includes("}") &&
                      !text.toLowerCase().includes("skip to content") &&
                      !text.toLowerCase().includes("open menu") &&
                      !text.toLowerCase().includes("close menu") &&
                      !text
                        .toLowerCase()
                        .includes("page you were looking for") &&
                      !text.toLowerCase().includes("couldn't find")
                    ) {
                      paragraphs.push(text);
                      log(
                        `Personal Site: Found paragraph (${
                          text.length
                        } chars): "${text.substring(0, 50)}..."`
                      );
                    }
                  }

                  if (paragraphs.length > 0) {
                    // Take up to first 3 paragraphs, max 1000 chars
                    result.bio = paragraphs
                      .slice(0, 3)
                      .join(" ")
                      .substring(0, 1000);
                    log(
                      `Personal Site: Found bio on about page (${result.bio.length} chars)`
                    );

                    // Also check about page for a better image if we don't have one
                    if (!result.imageUrl) {
                      for (const pattern of imgPatterns) {
                        const matches = aboutHtml.matchAll(pattern);
                        for (const match of matches) {
                          let imgUrl = match[1];
                          if (!imgUrl) continue;
                          if (
                            imgUrl.includes("icon") ||
                            imgUrl.includes("logo") ||
                            imgUrl.includes("button") ||
                            imgUrl.includes("favicon")
                          ) {
                            continue;
                          }
                          if (!imgUrl.startsWith("http")) {
                            imgUrl = new URL(imgUrl, aboutUrl).href;
                          }
                          result.imageUrl = imgUrl;
                          log(`Personal Site: Found image on about page`);
                          break;
                        }
                        if (result.imageUrl) break;
                      }
                    }
                    break;
                  } else {
                    log(
                      `Personal Site: No valid paragraphs found on ${aboutPath}`
                    );
                  }
                } catch (e) {
                  // About page doesn't exist, try next
                  continue;
                }
              }
            }

            if (result.imageUrl || result.bio) {
              return result;
            }
          } catch (error) {
            log(`Personal Site: Error for ${domain}: ${error.message}`);
            continue; // Try next domain
          }
        }

        log("Personal Site: No site found", "error");
        return null;
      }

      // Search IMDB for image (many narrators are also actors)
      async function searchIMDB(name) {
        log(`IMDB: Starting search for "${name}"`, "info");

        try {
          let profilePath = null;
          let verifiedName = null;
          let suggestionImage = null;

          // Strategy 1: Try IMDB's suggestion API to get profile ID
          const firstLetter = name.charAt(0).toLowerCase();
          const suggestionUrl = `https://v2.sg.media-imdb.com/suggestion/${firstLetter}/${encodeURIComponent(
            name.toLowerCase().replace(/\s+/g, "_")
          )}.json`;

          try {
            log(`IMDB: Trying suggestion API...`);
            const jsonText = await fetchViaProxy(suggestionUrl);
            const data = JSON.parse(jsonText);
            log(`IMDB: Suggestion API returned ${data.d?.length || 0} results`);

            if (data.d && data.d.length > 0) {
              // Find the best match - look for exact name match first
              const searchNameLower = name.toLowerCase();
              let bestMatch = null;

              for (const person of data.d) {
                // Only look at name entries (id starts with 'nm')
                if (!person.id || !person.id.startsWith("nm")) continue;

                const personNameLower = (person.l || "").toLowerCase();

                // Check if names match
                if (
                  personNameLower === searchNameLower ||
                  personNameLower.includes(searchNameLower) ||
                  searchNameLower.includes(personNameLower)
                ) {
                  bestMatch = person;
                  break;
                }
              }

              // If no exact match, take first person result
              if (!bestMatch) {
                bestMatch = data.d.find((p) => p.id?.startsWith("nm"));
              }

              if (bestMatch) {
                // Verify name matches
                const foundNameLower = (bestMatch.l || "").toLowerCase();
                const searchParts = name.toLowerCase().split(/\s+/);
                const foundParts = foundNameLower.split(/\s+/);

                const lastNameSearch = searchParts[searchParts.length - 1];
                const lastNameFound = foundParts[foundParts.length - 1];

                if (lastNameFound === lastNameSearch) {
                  profilePath = `/name/${bestMatch.id}`;
                  verifiedName = bestMatch.l;
                  log(
                    `IMDB: Found "${bestMatch.l}" via suggestion API (${bestMatch.id})`
                  );

                  // Save suggestion image as fallback
                  if (bestMatch.i && bestMatch.i.imageUrl) {
                    suggestionImage = bestMatch.i.imageUrl.replace(
                      /U[XY]\d+/g,
                      "UX400"
                    );
                  }
                } else {
                  log(
                    `IMDB: Name mismatch - searched "${name}" but found "${bestMatch.l}"`,
                    "warning"
                  );
                }
              }
            }
          } catch (e) {
            log(`IMDB: Suggestion API failed: ${e.message}`, "warning");
          }

          // Strategy 2: If no profile from suggestion, try regular search
          if (!profilePath) {
            const searchUrl = `https://www.imdb.com/find/?q=${encodeURIComponent(
              name
            )}&s=nm`;
            const html = await fetchViaProxy(searchUrl);

            log(`IMDB: Search page fetched, length: ${html.length}`);

            // Try multiple patterns to find the profile URL
            const patterns = [
              /href="(\/name\/nm\d+)\/?"/i,
              /href='(\/name\/nm\d+)\/?'/i,
              /\/name\/(nm\d+)/i,
              /"(nm\d+)"/,
            ];

            for (const pattern of patterns) {
              const match = html.match(pattern);
              if (match) {
                profilePath = match[1].startsWith("/")
                  ? match[1]
                  : `/name/${match[1]}`;
                log(`IMDB: Found profile path with pattern: ${profilePath}`);
                break;
              }
            }
          }

          if (!profilePath) {
            log("IMDB: No profile found", "error");
            return null;
          }

          const profileUrl = `https://www.imdb.com${profilePath}/`;
          log(`IMDB: Fetching profile page: ${profileUrl}`);

          // Fetch the actual profile page to get multiple images
          const profileHtml = await fetchViaProxy(profileUrl);
          log(`IMDB: Profile page fetched, length: ${profileHtml.length}`);

          const result = {
            source: "imdb",
            url: profileUrl,
            imageUrl: null,
            images: [],
            name: verifiedName || null,
            bio: null,
          };

          const foundImages = new Set();
          const maxImages = 8;

          // Add suggestion image first if we have it
          if (suggestionImage) {
            foundImages.add(suggestionImage);
            result.images.push(suggestionImage);
            result.imageUrl = suggestionImage;
          }

          // Extract name from profile if not already verified
          if (!result.name) {
            const titleMatch = profileHtml.match(/<title>([^|<]+)/i);
            if (titleMatch) {
              result.name = titleMatch[1].replace(" - IMDb", "").trim();
              log(`IMDB: Found name: ${result.name}`);
            }
          }

          // Extract bio from IMDB profile
          // IMDB modern pages use JSON-LD and various data attributes
          log(`IMDB: Looking for bio in profile page...`);

          // Helper function to clean IMDB bio text
          const cleanImdbBio = (bio, personName) => {
            if (!bio) return bio;

            let cleaned = bio
              .replace(/<[^>]*>/g, " ") // Remove HTML tags
              .replace(/&amp;/g, "&")
              .replace(/&quot;/g, '"')
              .replace(/&#x27;/g, "'")
              .replace(/&#39;/g, "'")
              .replace(/&nbsp;/g, " ")
              .replace(/\s+/g, " ")
              .trim();

            // Remove "Name. Role: Title." prefix pattern
            // e.g., "Alan Kelly. Actor: The Penguin. Dublin born..."
            const prefixPattern =
              /^[^.]+\.\s*(?:Actor|Actress|Director|Writer|Producer|Voice)[^.]*\.\s*/i;
            cleaned = cleaned.replace(prefixPattern, "");

            // Also try removing just the name at the start
            if (personName) {
              const namePattern = new RegExp(
                `^${personName.replace(
                  /[.*+?^${}()|[\]\\]/g,
                  "\\$&"
                )}[.,:]?\\s*`,
                "i"
              );
              cleaned = cleaned.replace(namePattern, "");
            }

            // Capitalize first letter after cleanup
            if (cleaned.length > 0) {
              cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
            }

            return cleaned;
          };

          // Try JSON-LD first - this is the most reliable on modern IMDB
          const jsonLdMatch = profileHtml.match(
            /<script type="application\/ld\+json">([\s\S]*?)<\/script>/i
          );
          if (jsonLdMatch) {
            try {
              const jsonData = JSON.parse(jsonLdMatch[1]);
              if (jsonData.description && jsonData.description.length > 50) {
                result.bio = cleanImdbBio(
                  jsonData.description,
                  result.name || name
                );
                log(
                  `IMDB: Found bio from JSON-LD (${result.bio.length} chars)`
                );
              }
            } catch (e) {
              log(`IMDB: JSON-LD parse failed`);
            }
          }

          // If no bio from JSON-LD, try other patterns
          if (!result.bio) {
            const bioPatterns = [
              // Mini bio section - new IMDB format
              /data-testid="mini-bio"[^>]*>([\s\S]*?)<\/div>/i,
              /data-testid="bio-content"[^>]*>([\s\S]*?)<\/div>/i,
              // Overview/about section
              /class="[^"]*(?:bio|about|overview)[^"]*"[^>]*>([\s\S]*?)<\/(?:div|p|span)>/i,
              // Any paragraph with substantial text near "bio" or "about"
              /(?:bio|about|overview)[^>]*>[\s\S]{0,200}<p[^>]*>([\s\S]*?)<\/p>/i,
            ];

            for (const pattern of bioPatterns) {
              const match = profileHtml.match(pattern);
              if (match && match[1]) {
                let bio = cleanImdbBio(match[1], result.name || name);

                if (bio.length > 50 && bio.length < 2000) {
                  result.bio = bio;
                  log(`IMDB: Found bio via pattern (${bio.length} chars)`);
                  break;
                }
              }
            }
          }

          // Also try to get bio from the /bio page if not found
          if (!result.bio) {
            try {
              const bioUrl = `https://www.imdb.com${profilePath}/bio/`;
              log(`IMDB: No bio on profile, checking bio page: ${bioUrl}`);
              const bioHtml = await fetchViaProxy(bioUrl);
              log(`IMDB: Bio page fetched, length: ${bioHtml.length}`);

              // Try JSON-LD on bio page too
              const bioJsonMatch = bioHtml.match(
                /<script type="application\/ld\+json">([\s\S]*?)<\/script>/i
              );
              if (bioJsonMatch) {
                try {
                  const jsonData = JSON.parse(bioJsonMatch[1]);
                  if (
                    jsonData.description &&
                    jsonData.description.length > 50
                  ) {
                    result.bio = cleanImdbBio(
                      jsonData.description,
                      result.name || name
                    );
                    log(
                      `IMDB: Found bio from bio page JSON-LD (${result.bio.length} chars)`
                    );
                  }
                } catch (e) {}
              }

              // Look for mini bio section with various patterns
              if (!result.bio) {
                const bioPagePatterns = [
                  /Mini Bio[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i,
                  /data-testid="sub-section-mini_bio"[\s\S]*?<div[^>]*>([\s\S]*?)<\/div>/i,
                  /<div[^>]*class="[^"]*ipc-html-content-inner-div[^"]*"[^>]*>([\s\S]*?)<\/div>/i,
                  /class="soda[^"]*"[^>]*>([\s\S]*?)<\/div>/i,
                ];

                for (const pattern of bioPagePatterns) {
                  const match = bioHtml.match(pattern);
                  if (match && match[1]) {
                    let bio = cleanImdbBio(match[1], result.name || name);

                    if (bio.length > 50) {
                      result.bio = bio.substring(0, 1500);
                      log(
                        `IMDB: Found bio from bio page (${result.bio.length} chars)`
                      );
                      break;
                    }
                  }
                }
              }
            } catch (e) {
              log(`IMDB: Bio page fetch failed: ${e.message}`, "warning");
            }
          }

          if (!result.bio) {
            log(`IMDB: No bio found for this person`);
          }

          // Skip name verification if we already verified via suggestion API
          if (!verifiedName) {
            // IMPORTANT: Verify this is the right person!
            // Compare the found name with what we searched for
            const searchNameLower = name.toLowerCase().replace(/[^a-z]/g, "");
            const foundNameLower = (result.name || "")
              .toLowerCase()
              .replace(/[^a-z]/g, "");

            // Check if names are similar enough
            const searchParts = name
              .toLowerCase()
              .split(/\s+/)
              .filter((p) => p.length > 0);
            const foundParts = (result.name || "")
              .toLowerCase()
              .split(/[\s.]+/)
              .filter((p) => p.length > 0);

            // At least the last name should match, or significant overlap
            const lastNameSearch = searchParts[searchParts.length - 1];
            const lastNameFound = foundParts[foundParts.length - 1];

            const firstNameSearch = searchParts[0];
            const firstNameFound = foundParts[0];

            const lastNameMatches =
              lastNameFound &&
              lastNameSearch &&
              (lastNameFound === lastNameSearch ||
                lastNameFound.includes(lastNameSearch) ||
                lastNameSearch.includes(lastNameFound));
            const firstNameMatches =
              firstNameFound &&
              firstNameSearch &&
              (firstNameFound === firstNameSearch ||
                firstNameFound.includes(firstNameSearch) ||
                firstNameSearch.includes(firstNameFound) ||
                firstNameFound[0] === firstNameSearch[0]); // Initial match (R.C. vs RC)

            // If found name has more parts than search (like middle names),
            // be stricter - require exact first AND last name match
            if (foundParts.length > searchParts.length) {
              const exactFirstMatch =
                firstNameFound === firstNameSearch ||
                (firstNameSearch.length <= 3 &&
                  firstNameFound.startsWith(firstNameSearch));
              const exactLastMatch = lastNameFound === lastNameSearch;

              if (!exactFirstMatch || !exactLastMatch) {
                log(
                  `IMDB: Name has extra parts - searched "${name}" but found "${result.name}" - might be different person, skipping`,
                  "error"
                );
                return null;
              }
            }

            if (!lastNameMatches) {
              log(
                `IMDB: Name mismatch! Searched "${name}" but found "${result.name}" - skipping`,
                "error"
              );
              return null;
            }

            if (!firstNameMatches && !lastNameMatches) {
              log(
                `IMDB: Name mismatch! Searched "${name}" but found "${result.name}" - skipping`,
                "error"
              );
              return null;
            }

            log(
              `IMDB: Name verified - "${result.name}" matches search "${name}"`
            );

            // Additional check: Look for narrator/audiobook keywords on the profile page
            const bioLower = profileHtml.toLowerCase();
            const isNarratorOnIMDB =
              bioLower.includes("narrator") ||
              bioLower.includes("audiobook") ||
              bioLower.includes("voice actor") ||
              bioLower.includes("voice-over") ||
              bioLower.includes("voiceover");

            // If this person has a middle name/initial that we didn't search for,
            // AND they're not clearly identified as a narrator on IMDB, skip them
            if (foundParts.length > searchParts.length && !isNarratorOnIMDB) {
              log(
                `IMDB: "${result.name}" doesn't appear to be an audiobook narrator, skipping`,
                "error"
              );
              return null;
            }
          }

          // IMDB headshots are specifically in the profile header area
          // They have specific patterns like:
          // - Appear near "View Poster" or in the header section
          // - Usually have portrait crop ratios like CR13,0,140,207 or UY207
          // - Movie posters have different crops like CR22,0,90,133

          // Extract bio from profile page
          const bioPatterns = [
            // Mini bio section
            /data-testid="mini-bio"[^>]*>([^<]+)/i,
            // Bio text in various containers
            /<div[^>]*class="[^"]*inline[^"]*"[^>]*data-testid="bio-content"[^>]*>([^<]+)/i,
            // Overview section
            /class="[^"]*ipc-overviewCard[^"]*"[^>]*>.*?<div[^>]*>([^<]{50,})/is,
            // Known for description
            /"description"\s*:\s*"([^"]{50,})"/i,
            // Any substantial text near "bio"
            /bio[^>]*>([^<]{100,})</i,
          ];

          for (const pattern of bioPatterns) {
            const bioMatch = profileHtml.match(pattern);
            if (bioMatch && bioMatch[1]) {
              const bioText = stripHtml(bioMatch[1]).trim();
              if (
                bioText.length > 50 &&
                !bioText.includes("{") &&
                !bioText.includes("function")
              ) {
                result.bio = bioText.substring(0, 1000);
                log(`IMDB: Found bio (${result.bio.length} chars)`);
                break;
              }
            }
          }

          // Also try to fetch the bio page for more complete bio
          if (!result.bio || result.bio.length < 200) {
            try {
              const bioUrl = `https://www.imdb.com${profilePath}/bio/`;
              log(`IMDB: Fetching bio page...`);
              const bioHtml = await fetchViaProxy(bioUrl);

              // Look for mini bio or biography text
              const bioPatternsPage = [
                /<div[^>]*data-testid="sub-section-mini_bio"[^>]*>[\s\S]*?<div[^>]*class="[^"]*ipc-html-content[^"]*"[^>]*>([^<]+(?:<[^>]+>[^<]*)*)/i,
                /Mini Bio[^<]*<\/h[^>]*>[\s\S]*?<p[^>]*>([^<]+)/i,
                /<p[^>]*class="[^"]*ipc-html-content[^"]*"[^>]*>([^<]+)/i,
              ];

              for (const pattern of bioPatternsPage) {
                const match = bioHtml.match(pattern);
                if (match && match[1]) {
                  const bioText = stripHtml(match[1]).trim();
                  if (bioText.length > 100) {
                    result.bio = bioText.substring(0, 1000);
                    log(
                      `IMDB: Found bio from bio page (${result.bio.length} chars)`
                    );
                    break;
                  }
                }
              }
            } catch (e) {
              log(`IMDB: Bio page fetch failed: ${e.message}`);
            }
          }

          // First, look for images that appear to be headshots (portrait crops)
          // Portrait aspect ratio for headshots is usually ~140x207 or similar
          const headshotPatterns = [
            // Look for the main profile image (usually first in header)
            /class="[^"]*ipc-image[^"]*"[^>]*src="(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+)"/gi,
            // Images with portrait crop ratios (width < height significantly)
            /(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+_CR\d+,0,140,207_[^"]+\.jpg)/gi,
            /(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+_UY207_[^"]+\.jpg)/gi,
            /(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+_UY317_[^"]+\.jpg)/gi,
            /(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+_SY317_[^"]+\.jpg)/gi,
            // Publicity images
            /(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+Publicity[^"]+\.jpg)/gi,
            // General M images (person photos)
            /(https:\/\/m\.media-amazon\.com\/images\/M\/MV[^"]+\.jpg)/gi,
          ];

          // Collect all matching images
          for (const pattern of headshotPatterns) {
            if (result.images.length >= maxImages) break;

            const matches = profileHtml.matchAll(pattern);
            for (const match of matches) {
              if (result.images.length >= maxImages) break;

              let imgUrl = match[1];

              // Skip movie posters (90x133 is typical movie poster crop)
              if (
                imgUrl.includes("CR22,0,90,133") ||
                imgUrl.includes("_UX90_")
              ) {
                continue;
              }

              // Upgrade to larger size
              imgUrl = imgUrl.replace(/\._V1_[^.]+\.jpg/, "._V1_UX400.jpg");

              if (!foundImages.has(imgUrl)) {
                foundImages.add(imgUrl);
                result.images.push(imgUrl);
                if (!result.imageUrl) {
                  result.imageUrl = imgUrl;
                  log(`IMDB: Found headshot: ${imgUrl.substring(0, 70)}...`);
                }
              }
            }
          }

          // If we found images from the profile page, also try media index for more
          if (result.images.length < maxImages) {
            const hasPhotos =
              profileHtml.includes("/mediaindex") ||
              profileHtml.includes("Photos<");
            if (hasPhotos) {
              // Try the media index page for this person
              const mediaUrl = `https://www.imdb.com${profilePath}/mediaindex/`;
              log(`IMDB: Checking media page for more images...`);

              try {
                const mediaHtml = await fetchViaProxy(mediaUrl);
                // Look for all images on media page
                const mediaPattern =
                  /(https:\/\/m\.media-amazon\.com\/images\/M\/MV[^"]+\.jpg)/gi;
                const mediaMatches = mediaHtml.matchAll(mediaPattern);

                for (const match of mediaMatches) {
                  if (result.images.length >= maxImages) break;

                  let imgUrl = match[1];
                  imgUrl = imgUrl.replace(/\._V1_[^.]+\.jpg/, "._V1_UX400.jpg");

                  if (!foundImages.has(imgUrl)) {
                    foundImages.add(imgUrl);
                    result.images.push(imgUrl);
                    if (!result.imageUrl) result.imageUrl = imgUrl;
                  }
                }

                if (result.images.length > 1) {
                  log(
                    `IMDB: Found ${result.images.length} images total from profile + media pages`
                  );
                }
              } catch (e) {
                log(`IMDB: Media page fetch failed: ${e.message}`);
              }
            }
          }

          if (result.images.length > 0 || result.bio) {
            log(
              `IMDB: Returning ${result.images.length} images, bio: ${
                result.bio ? result.bio.length + " chars" : "none"
              }`
            );
            return result;
          }

          log("IMDB: No images or bio found", "error");
          return null;
        } catch (error) {
          log(`IMDB: Error - ${error.message}`, "error");
          return null;
        }
      }

      // Google search for narrator info and images
      async function searchGoogle(name) {
        // Use Google's search with specific terms for audiobook narrators
        const searchQueries = [
          `${name} narrator audiobook`,
          `${name} voice actor`,
          `"${name}" narrator`,
        ];

        log(`Google: Searching for "${name}"`);

        try {
          const result = {
            source: "google",
            url: `https://www.google.com/search?q=${encodeURIComponent(
              searchQueries[0]
            )}`,
            imageUrl: null,
            images: [],
          };

          const foundImages = new Set();
          const maxImages = 5; // Collect up to 5 images

          // Try each search query
          for (const searchQuery of searchQueries) {
            if (result.images.length >= maxImages) break;

            // Try Google Images
            const imageSearchUrl = `https://www.google.com/search?q=${encodeURIComponent(
              searchQuery
            )}&tbm=isch`;

            try {
              const html = await fetchViaProxy(imageSearchUrl);

              // Google Images embeds image URLs in various formats
              const patterns = [
                /\["(https:\/\/[^"]+\.(?:jpg|jpeg|png))"[^\]]*,\s*\d+,\s*\d+\]/gi,
                /"ou":"(https:\/\/[^"]+\.(?:jpg|jpeg|png)[^"]*)"/gi,
                /\["(https:\/\/[^"]+\.(?:jpg|jpeg|png))",\d+,\d+\]/gi,
                /data-src="(https:\/\/[^"]+\.(?:jpg|jpeg|png)[^"]*)"/gi,
                /src="(https:\/\/encrypted-tbn[^"]+)"/gi,
                /"(https:\/\/i1\.sndcdn\.com\/[^"]+)"/gi, // SoundCloud images
                /"(https:\/\/[^"]*avatars[^"]*\.(?:jpg|jpeg|png)[^"]*)"/gi,
              ];

              for (const pattern of patterns) {
                if (result.images.length >= maxImages) break;

                const matches = html.matchAll(pattern);
                for (const match of matches) {
                  if (result.images.length >= maxImages) break;

                  const imgUrl = match[1];
                  // Skip Google's own assets and tiny images
                  if (
                    !imgUrl.includes("google.com") &&
                    !imgUrl.includes("gstatic.com") &&
                    !imgUrl.includes("googleapis.com") &&
                    !imgUrl.includes("icon") &&
                    !imgUrl.includes("logo") &&
                    !imgUrl.includes("button") &&
                    !imgUrl.includes("1x1") &&
                    !imgUrl.includes("placeholder") &&
                    imgUrl.length > 50 &&
                    !foundImages.has(imgUrl)
                  ) {
                    foundImages.add(imgUrl);
                    result.images.push(imgUrl);
                    if (!result.imageUrl) result.imageUrl = imgUrl;
                    log(`Google: Found image ${result.images.length}`);
                  }
                }
              }
            } catch (e) {
              log(
                `Google: Image search failed for "${searchQuery}": ${e.message}`
              );
            }
          }

          // Try DuckDuckGo as fallback if no images found
          if (result.images.length === 0) {
            try {
              const ddgUrl = `https://duckduckgo.com/?q=${encodeURIComponent(
                name + " narrator"
              )}&iax=images&ia=images`;
              const ddgHtml = await fetchViaProxy(ddgUrl);

              // DuckDuckGo image patterns
              const ddgPatterns = [
                /"image":"(https:\/\/[^"]+\.(?:jpg|jpeg|png)[^"]*)"/gi,
                /vqd=([^&]+)/,
              ];

              for (const pattern of ddgPatterns) {
                const match = ddgHtml.match(pattern);
                if (match && match[1] && match[1].startsWith("http")) {
                  result.imageUrl = match[1];
                  result.images.push(match[1]);
                  log(`Google: Found image via DuckDuckGo`);
                  break;
                }
              }
            } catch (e) {
              log(`DuckDuckGo fallback failed: ${e.message}`);
            }
          }

          if (result.images.length > 0) {
            log(`Google: Found ${result.images.length} images`);
            return result;
          }

          log("Google: No image found", "error");
          return null;
        } catch (error) {
          log(`Google: Error - ${error.message}`, "error");
          return null;
        }
      }

      // Search Wikimedia Commons for image
      async function searchWikimediaCommons(name) {
        const searchUrl = `https://commons.wikimedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(
          name
        )}&srnamespace=6&format=json&origin=*`;
        log(`Wikimedia Commons: Searching for ${name}`);

        try {
          const response = await fetch(searchUrl);
          if (!response.ok) {
            log("Wikimedia Commons: Search failed", "error");
            return null;
          }

          const data = await response.json();
          const results = data.query?.search || [];

          // Look for a portrait/photo file
          for (const result of results) {
            const title = result.title;
            if (
              title.match(/\.(jpg|jpeg|png)$/i) &&
              (title.toLowerCase().includes(name.toLowerCase().split(" ")[1]) ||
                title.toLowerCase().includes("portrait") ||
                title.toLowerCase().includes("photo"))
            ) {
              // Get the actual file URL
              const fileInfoUrl = `https://commons.wikimedia.org/w/api.php?action=query&titles=${encodeURIComponent(
                title
              )}&prop=imageinfo&iiprop=url&format=json&origin=*`;
              const fileResponse = await fetch(fileInfoUrl);
              const fileData = await fileResponse.json();

              const pages = fileData.query?.pages || {};
              const page = Object.values(pages)[0];
              const imageUrl = page?.imageinfo?.[0]?.url;

              if (imageUrl) {
                log(`Wikimedia Commons: Found image`);
                return {
                  source: "wikimedia",
                  url: `https://commons.wikimedia.org/wiki/${encodeURIComponent(
                    title
                  )}`,
                  imageUrl: imageUrl,
                };
              }
            }
          }

          log("Wikimedia Commons: No suitable image found", "error");
          return null;
        } catch (error) {
          log(`Wikimedia Commons: Error - ${error.message}`, "error");
          return null;
        }
      }

      // Dedicated image search as fallback
      async function searchForImage(name, existingResults) {
        // Check if we already have an image
        for (const result of existingResults) {
          if (result?.imageUrl) {
            return null; // Already have an image
          }
        }

        log(
          "No image found in primary sources, trying fallback image searches..."
        );

        // Try IMDB first (best for actors/narrators)
        const imdbResult = await searchIMDB(name);
        if (imdbResult?.imageUrl) {
          return imdbResult;
        }

        // Try Wikimedia Commons
        const commonsResult = await searchWikimediaCommons(name);
        if (commonsResult?.imageUrl) {
          return commonsResult;
        }

        return null;
      }

      // Image quality/priority scoring
      function scoreImage(imageUrl, source) {
        if (!imageUrl) return 0;

        // Blocklist of known wrong person images - reject these completely
        const blockedImages = [
          "MV5BZWZmNDU4NjAtZTQxNC00ODg3LWFhZjgtODNiODc1N2I1M2M3", // Wayne T. Carr (actor, not narrator)
        ];

        for (const blocked of blockedImages) {
          if (imageUrl.includes(blocked)) {
            log(`Blocked known wrong-person image: ${blocked}`, "error");
            return -1000; // Return very negative score to filter out
          }
        }

        let score = 0;

        // Prioritize by source (headshot-focused sources score higher)
        const sourceScores = {
          imdb: 100,
          wikipedia: 90,
          voicestoknow: 85,
          audiofile: 85,
          soundcloud: 80,
          soundbooth: 75,
          audible: 50,
          tantor: 40,
          google: 20,
        };
        score += sourceScores[source] || 10;

        // CRITICAL: Distinguish IMDB headshots (/images/M/) from product images (/images/I/)
        if (imageUrl.includes("/images/M/")) {
          score += 50;
        }
        if (imageUrl.includes("/images/I/")) {
          score -= 80;
        }

        // Penalize likely book covers
        if (imageUrl.includes("_SL") || imageUrl.includes("_AC_")) {
          score -= 60;
        }
        if (imageUrl.includes("cover") || imageUrl.includes("book")) {
          score -= 40;
        }

        // Boost likely headshots/portraits
        if (imageUrl.includes("portrait") || imageUrl.includes("headshot")) {
          score += 30;
        }
        if (imageUrl.includes("avatar") || imageUrl.includes("profile")) {
          score += 25;
        }
        if (imageUrl.includes("narrator-portrait")) {
          score += 40;
        }
        if (imageUrl.includes("sndcdn.com/avatars")) {
          score += 35;
        }
        if (imageUrl.includes("wikipedia") || imageUrl.includes("wikimedia")) {
          score += 25;
        }
        if (
          imageUrl.includes("500") ||
          imageUrl.includes("400") ||
          imageUrl.includes("1080")
        ) {
          score += 10;
        }

        return score;
      }

// ============================================
      // TRANSLITERATION FOR INTERNATIONAL NAMES
      // ============================================
      
      // Transliteration maps for non-Latin scripts
      const CYRILLIC_MAP = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'shch',
        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
        // Ukrainian specific
        '—ñ': 'i', '—ó': 'yi', '—î': 'ye', '“ë': 'g',
        // Serbian/Macedonian specific  
        '—í': 'dj', '—ô': 'lj', '—ö': 'nj', '—õ': 'c', '—ü': 'dz',
        '—ò': 'j', '—ì': 'gj', '—ú': 'kj', '—ï': 'dz'
      };

      const GREEK_MAP = {
        'Œ±': 'a', 'Œ≤': 'b', 'Œ≥': 'g', 'Œ¥': 'd', 'Œµ': 'e', 'Œ∂': 'z', 'Œ∑': 'i',
        'Œ∏': 'th', 'Œπ': 'i', 'Œ∫': 'k', 'Œª': 'l', 'Œº': 'm', 'ŒΩ': 'n', 'Œæ': 'x',
        'Œø': 'o', 'œÄ': 'p', 'œÅ': 'r', 'œÉ': 's', 'œÇ': 's', 'œÑ': 't', 'œÖ': 'y',
        'œÜ': 'f', 'œá': 'ch', 'œà': 'ps', 'œâ': 'o'
      };

      // Transliterate text to ASCII-safe characters
      function transliterate(text) {
        let result = '';
        const lower = text.toLowerCase();
        
        for (let i = 0; i < lower.length; i++) {
          const char = lower[i];
          
          // Check Cyrillic
          if (CYRILLIC_MAP[char] !== undefined) {
            result += CYRILLIC_MAP[char];
          }
          // Check Greek
          else if (GREEK_MAP[char] !== undefined) {
            result += GREEK_MAP[char];
          }
          // Keep ASCII letters, numbers, spaces, hyphens
          else if (/[a-z0-9\s-]/.test(char)) {
            result += char;
          }
          // Handle accented Latin characters (√© -> e, √± -> n, etc.)
          else if (/[\u00C0-\u024F]/.test(char)) {
            const normalized = char.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            result += normalized.toLowerCase();
          }
          // For CJK and other scripts, keep as-is for URL encoding later
          else if (/[\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF]/.test(char)) {
            result += char;
          }
          // Skip other characters
        }
        
        return result;
      }

      // Convert name to a safe document ID for Firebase
      function nameToDocId(name) {
        if (!name) return 'unknown';
        
        // First, transliterate non-Latin characters
        let docId = transliterate(name.trim());
        
        // Convert spaces to hyphens and clean up
        docId = docId
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        
        // If we still have non-ASCII (like CJK), URL-encode those parts
        if (/[^\x00-\x7F]/.test(docId)) {
          docId = encodeURIComponent(docId)
            .replace(/%/g, '_')  // Replace % with underscore for Firebase
            .toLowerCase();
        }
        
        // If the result is empty or just hyphens, create a hash-based ID
        if (!docId || docId === '-' || !/[a-z0-9]/.test(docId)) {
          let hash = 0;
          for (let i = 0; i < name.length; i++) {
            const char = name.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
          }
          docId = 'narrator-' + Math.abs(hash).toString(36);
        }
        
        // Ensure it doesn't start with a number (Firebase restriction)
        if (/^\d/.test(docId)) {
          docId = 'n-' + docId;
        }
        
        return docId;
      }

      // Smart name capitalization
      function capitalizeName(name) {
        // Handle special prefixes that should have internal caps
        const specialPrefixes = ["mc", "mac", "o'"];

        return name
          .split(/\s+/)
          .map((word) => {
            if (!word) return "";

            // Check if word is all caps and 2-3 characters (likely initials like RC, JK, etc)
            if (
              word.length <= 3 &&
              word === word.toUpperCase() &&
              /^[A-Z]+$/.test(word)
            ) {
              return word; // Keep initials as-is
            }

            let result = word.toLowerCase();

            // Check for special prefixes
            for (const prefix of specialPrefixes) {
              if (result.startsWith(prefix) && result.length > prefix.length) {
                // Capitalize first letter and letter after prefix
                result =
                  prefix.charAt(0).toUpperCase() +
                  prefix.slice(1) +
                  result.charAt(prefix.length).toUpperCase() +
                  result.slice(prefix.length + 1);
                return result;
              }
            }

            // Handle hyphenated names (e.g., "Mary-Jane")
            if (result.includes("-")) {
              return result
                .split("-")
                .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
                .join("-");
            }

            // Standard capitalization
            return result.charAt(0).toUpperCase() + result.slice(1);
          })
          .join(" ");
      }

      // Merge results - keep all images and bios for selection
      function mergeResults(name, results) {
        // Use properly capitalized name from input
        const properName = capitalizeName(name);

        const merged = {
          name: properName, // Always use the name the user typed in
          images: [], // All found images with source info
          bios: [], // All found bios with source info
          selectedImage: null,
          selectedBio: null,
          tagline: null,
          books: [],
          awards: [],
          accents: [],
          genres: [],
          sources: [],
        };

        for (const result of results.filter((r) => r !== null)) {
          merged.sources.push({ name: result.source, url: result.url });

          // Collect images with score and source (support both single imageUrl and array of images)
          const imagesToProcess = [];

          // Handle single imageUrl (backwards compatibility)
          if (result.imageUrl) {
            imagesToProcess.push(result.imageUrl);
          }

          // Handle array of images
          if (result.images && Array.isArray(result.images)) {
            imagesToProcess.push(...result.images);
          }

          // Process all images from this source
          for (const imgUrl of imagesToProcess) {
            if (!imgUrl) continue;

            // Check for duplicates
            if (merged.images.some((i) => i.url === imgUrl)) continue;

            const score = scoreImage(imgUrl, result.source);
            // Only include images with positive scores (negative = blocked)
            if (score > 0) {
              merged.images.push({
                url: imgUrl,
                source: result.source,
                score,
                sourceUrl: result.url,
              });
              log(`Image from ${result.source}: score ${score}`);
            } else {
              log(
                `Image from ${result.source}: BLOCKED (score ${score})`,
                "error"
              );
            }
          }

          // Collect bio with source
          if (result.bio && result.bio.length > 20) {
            // Check if we already have a very similar bio
            const isDuplicate = merged.bios.some(
              (b) => b.text.substring(0, 100) === result.bio.substring(0, 100)
            );
            if (!isDuplicate) {
              merged.bios.push({
                text: result.bio,
                source: result.source,
                sourceUrl: result.url,
                length: result.bio.length,
              });
            }
          }

          if (result.tagline && !merged.tagline) {
            // Filter out HTML attributes that might have been incorrectly extracted
            if (
              !result.tagline.includes("itemtype") &&
              !result.tagline.includes("schema.org") &&
              !result.tagline.includes("http") &&
              !result.tagline.includes("class=") &&
              !result.tagline.includes("://")
            ) {
              merged.tagline = result.tagline;
            }
          }

          if (result.books) {
            result.books.forEach((b) => {
              if (!merged.books.includes(b)) merged.books.push(b);
            });
          }

          if (result.awards) {
            result.awards.forEach((a) => {
              if (
                !merged.awards.some((x) => x.toLowerCase() === a.toLowerCase())
              ) {
                merged.awards.push(a);
              }
            });
          }

          if (result.accents) {
            result.accents.forEach((a) => {
              if (!merged.accents.includes(a)) merged.accents.push(a);
            });
          }

          if (result.genres) {
            result.genres.forEach((g) => {
              if (!merged.genres.includes(g)) merged.genres.push(g);
            });
          }
        }

        // Sort images by score (best first)
        merged.images.sort((a, b) => b.score - a.score);

        // Sort bios by length (longest first, usually most detailed)
        merged.bios.sort((a, b) => b.length - a.length);

        // Log rankings
        if (merged.images.length > 0) {
          log(`--- Image Rankings ---`);
          merged.images.forEach((img, i) => {
            log(
              `${i + 1}. [${img.source}] Score: ${
                img.score
              } - ${img.url.substring(0, 60)}...`
            );
          });
          log(`----------------------`);
          // Pre-select best image
          merged.selectedImage = 0;
        }

        if (merged.bios.length > 0) {
          log(`--- Bio Rankings ---`);
          merged.bios.forEach((bio, i) => {
            log(`${i + 1}. [${bio.source}] ${bio.length} chars`);
          });
          log(`----------------------`);
          // Pre-select longest bio
          merged.selectedBio = 0;
        }

        return merged;
      }

      async function performSearch(skipDatabaseCheck = false) {
        const narratorName = searchInput.value.trim();
        if (!narratorName) {
          showError("Please enter a narrator name");
          return;
        }

        // Reset UI
        if (debugLog) debugLog.innerHTML = "";
        loading.classList.add("active");
        resultCard.classList.remove("active");
        document.getElementById("existingProfileCard").style.display = "none";
        document.getElementById("stillSearching").style.display = "none";
        errorMessage.classList.remove("active");
        suggestions.style.display = "none";
        searchBtn.disabled = true;

        if (!skipDatabaseCheck) {
  existingNarratorData = null;
}
        // Reset firebase submit button
        const firebaseBtn = document.getElementById("firebaseBtn");
        if (firebaseBtn) {
          firebaseBtn.disabled = false;
          firebaseBtn.classList.remove("success", "error", "uploading");
          firebaseBtn.innerHTML = "‚òÅÔ∏è Submit to LitLyric Database";
        }

        log(`Starting search for "${narratorName}"`);
        log(`skipDatabaseCheck = ${skipDatabaseCheck}`);

        // Check if narrator exists in database first (unless skipping for change request)
        if (!skipDatabaseCheck) {
          log("Checking LitLyric database...", "info");
          const existing = await checkExistingNarrator(narratorName);

          if (existing) {
            // Show existing profile instead of searching
            loading.classList.remove("active");
            searchBtn.disabled = false;
            displayExistingProfile(existing, narratorName);
            return;
          }

          log("Not found in database, searching external sources...", "info");
        }

        // Check fast mode
        const fastMode =
          document.getElementById("fastModeToggle")?.checked || false;

        log(`Searching external sources${fastMode ? " (Fast Mode)" : ""}...`);

        // Setup progress indicators
        sourceProgress.innerHTML = Object.entries(SOURCES)
          .map(
            ([key, src]) =>
              `<span class="source-status" id="status-${key}">${src.icon} ${src.name}</span>`
          )
          .join("");

        try {
          // Collect results as they come in
          const liveResults = [];
          let searchComplete = false;
          const stillSearchingEl = document.getElementById("stillSearching");
          let userHasSelectedImage = false;
          let userHasSelectedBio = false;

          // Function to update display with current results
          const updateLiveDisplay = () => {
            if (liveResults.length > 0) {
              const merged = mergeResults(
                narratorName,
                liveResults.filter((r) => r)
              );
              if (merged.sources.length > 0) {
                // Preserve user's selections if they've made any
                if (currentData && userHasSelectedImage) {
                  merged.selectedImage = currentData.selectedImage;
                }
                if (currentData && userHasSelectedBio) {
                  merged.selectedBio = currentData.selectedBio;
                }

                loading.classList.remove("active");
                stillSearchingEl.style.display = "flex";
                displayResult(merged);
                resultCard.classList.add("active");
              }
            }
          };

          // Track when user makes a selection
          window.userSelectedImage = () => {
            userHasSelectedImage = true;
          };
          window.userSelectedBio = () => {
            userHasSelectedBio = true;
          };

          // Create search functions that update live
          const createSearch = (
            name,
            searchFn,
            timeout,
            statusKey,
            checkImage = false
          ) => {
            return (async () => {
              updateSourceStatus(statusKey, "searching");
              try {
                const r = await fetchWithTimeout(searchFn, timeout);
                const found = checkImage ? r?.imageUrl : r;
                updateSourceStatus(statusKey, found ? "found" : "not-found");
                if (r) {
                  liveResults.push(r);
                  if (!searchComplete) updateLiveDisplay();
                }
                return r;
              } catch (e) {
                updateSourceStatus(statusKey, "not-found");
                log(`${name}: Timeout or error`, "warning");
                return null;
              }
            })();
          };

          // Core sources (always search these)
          const coreSearches = [
            createSearch(
              "Audible",
              searchAudible(narratorName),
              45000,
              "audible"
            ),
            createSearch(
              "Wikipedia",
              searchWikipedia(narratorName),
              45000,
              "wikipedia"
            ),
            createSearch(
              "AudioFile",
              searchAudioFile(narratorName),
              45000,
              "audiofile"
            ),
            createSearch("Tantor", searchTantor(narratorName), 30000, "tantor"),
            createSearch("IMDB", searchIMDB(narratorName), 45000, "imdb", true),
            createSearch(
              "Google",
              searchGoogle(narratorName),
              30000,
              "google",
              true
            ),
          ];

          // Additional sources (skip in fast mode)
          const additionalSearches = fastMode
            ? []
            : [
                createSearch(
                  "Personal Site",
                  searchPersonalSite(narratorName),
                  30000,
                  "personalsite"
                ),
                createSearch(
                  "Voices to Know",
                  searchVoicesToKnow(narratorName),
                  30000,
                  "voicestoknow"
                ),
                createSearch(
                  "Soundbooth",
                  searchSoundbooth(narratorName),
                  30000,
                  "soundbooth"
                ),
                createSearch(
                  "SoundCloud",
                  searchSoundCloud(narratorName),
                  30000,
                  "soundcloud"
                ),
              ];

          // Mark skipped sources in fast mode
          if (fastMode) {
            [
              "personalsite",
              "voicestoknow",
              "soundbooth",
              "soundcloud",
            ].forEach((src) => {
              updateSourceStatus(src, "not-found");
            });
          }

          // Wait for all searches to complete
          await Promise.all([...coreSearches, ...additionalSearches]);

          // Mark search as complete and hide indicator
          searchComplete = true;
          stillSearchingEl.style.display = "none";

          // Check if we have any image at all
          let hasImage = liveResults.some((r) => r?.imageUrl);

          const merged = mergeResults(
            narratorName,
            liveResults.filter((r) => r)
          );

          // Preserve user's selections if they've made any
          if (currentData && userHasSelectedImage) {
            merged.selectedImage = currentData.selectedImage;
          }
          if (currentData && userHasSelectedBio) {
            merged.selectedBio = currentData.selectedBio;
          }

          log(
            `Search complete. Sources found: ${merged.sources.length}`,
            "success"
          );
          log(
            `Images found: ${merged.images.length}`,
            merged.images.length > 0 ? "success" : "error"
          );
          log(
            `Bios found: ${merged.bios.length}`,
            merged.bios.length > 0 ? "success" : "error"
          );

          if (merged.sources.length === 0) {
            showError(
              `No information found for "${narratorName}". Try checking the spelling.`
            );
            return;
          }

          // Final display with all results
          searchComplete = true;
          displayResult(merged);
        } catch (error) {
          log(`Search failed: ${error.message}`, "error");
          // Only show error if we didn't get any results via live updates
          if (liveResults.length === 0) {
            showError("An error occurred. Please try again.");
          }
        } finally {
          loading.classList.remove("active");
          document.getElementById("stillSearching").style.display = "none";
          searchBtn.disabled = false;
        }
      }

      // Store current result data globally for selection
      let currentData = null;

      async function displayResult(data) {
        currentData = data;

        // Check if this is a change request (narrator already exists)
        const isChangeRequest = existingNarratorData !== null;

        // Update button visibility
        const newButtons = document.getElementById("newNarratorButtons");
        const existingButtons = document.getElementById(
          "existingNarratorButtons"
        );

        if (isChangeRequest) {
          // Show change request buttons
          newButtons.style.display = "none";
          existingButtons.style.display = "flex";
        } else {
          // Show upload button for new narrator
          newButtons.style.display = "flex";
          existingButtons.style.display = "none";
        }

        document.getElementById("narratorName").textContent = data.name;

        // Tagline
        const taglineEl = document.getElementById("narratorTagline");
        if (data.tagline) {
          taglineEl.textContent = `"${data.tagline}"`;
          taglineEl.style.display = "block";
        } else {
          taglineEl.style.display = "none";
        }

        // Source badges
        document.getElementById("sourceBadges").innerHTML = data.sources
          .map(
            (s) =>
              `<span class="source-badge">${SOURCES[s.name]?.icon || "üìÑ"} ${
                s.name
              }</span>`
          )
          .join("");

        // Image options
        const imageOptionsEl = document.getElementById("imageOptions");
        const imageSection = document.getElementById("imageSelectionSection");
        if (data.images.length > 0 || true) {
          // Always show section for custom input
          // Add "None" option first, then custom input, then found images
          let imagesHtml = `
                    <div class="image-option ${
                      data.selectedImage === null ? "selected" : ""
                    }" 
                         data-index="none" onclick="selectImage(null)">
                        <div class="no-image-option">
                            <span>‚úï</span>
                            <small>None</small>
                        </div>
                        <div class="image-option-check">‚úì</div>
                    </div>
                    <div class="image-option ${
                      data.selectedImage === "custom" ? "selected" : ""
                    }" 
                         data-index="custom" onclick="selectImage('custom')">
                        <div class="custom-image-option">
                            <span>Ôºã</span>
                            <small>Custom</small>
                        </div>
                        <div class="image-option-check">‚úì</div>
                    </div>
                `;
          imagesHtml += data.images
            .map(
              (img, i) => `
                    <div class="image-option ${
                      i === data.selectedImage ? "selected" : ""
                    }" 
                         data-index="${i}" onclick="selectImage(${i})">
                                                <img src="${getCdnImageUrl(
                                                  img.url
                                                )}" alt="Option ${i + 1}"
                             onerror="this.parentElement.style.display='none'">
                        <div class="image-option-info">
                            <div class="image-option-source">${
                              SOURCES[img.source]?.icon || "üìÑ"
                            } ${img.source}</div>
                            <div class="image-option-score">Score: ${
                              img.score
                            }</div>
                        </div>
                        <div class="image-option-check">‚úì</div>
                    </div>
                `
            )
            .join("");
          imageOptionsEl.innerHTML = imagesHtml;
          imageSection.style.display = "block";
        }

        // Custom image input
        const customImageInput = document.getElementById("customImageInput");
        customImageInput.style.display =
          data.selectedImage === "custom" ? "block" : "none";

        // Bio options
        const bioOptionsEl = document.getElementById("bioOptions");
        const bioSection = document.getElementById("bioSelectionSection");
        if (data.bios.length > 0 || true) {
          // Always show section for custom input
          // Add "None" option first, then custom, then found bios
          let biosHtml = `
                    <div class="bio-option ${
                      data.selectedBio === null ? "selected" : ""
                    }" 
                         data-index="none" onclick="selectBio(null)">
                        <div class="bio-option-header">
                            <span class="bio-option-source">‚úï None</span>
                            <div class="bio-option-check">${
                              data.selectedBio === null ? "‚úì" : ""
                            }</div>
                        </div>
                        <p class="bio-option-text" style="color: #666; font-style: italic;">No biography selected</p>
                    </div>
                    <div class="bio-option ${
                      data.selectedBio === "custom" ? "selected" : ""
                    }" 
                         data-index="custom" onclick="selectBio('custom')">
                        <div class="bio-option-header">
                            <span class="bio-option-source">Ôºã Custom</span>
                            <div class="bio-option-check">${
                              data.selectedBio === "custom" ? "‚úì" : ""
                            }</div>
                        </div>
                        <p class="bio-option-text" style="color: #666; font-style: italic;">Write your own biography</p>
                    </div>
                `;
          biosHtml += data.bios
            .map(
              (bio, i) => `
                    <div class="bio-option ${
                      i === data.selectedBio ? "selected" : ""
                    }" 
                         data-index="${i}" onclick="selectBio(${i})">
                        <div class="bio-option-header">
                            <span class="bio-option-source">${
                              SOURCES[bio.source]?.icon || "üìÑ"
                            } ${bio.source}</span>
                            <span class="bio-option-length">${
                              bio.length
                            } chars</span>
                            <div class="bio-option-check">${
                              i === data.selectedBio ? "‚úì" : ""
                            }</div>
                        </div>
                        <p class="bio-option-text">${bio.text}</p>
                    </div>
                `
            )
            .join("");
          bioOptionsEl.innerHTML = biosHtml;
          bioSection.style.display = "block";
        }

        // Custom bio input
        const customBioInput = document.getElementById("customBioInput");
        customBioInput.style.display =
          data.selectedBio === "custom" ? "block" : "none";

        // Awards
        const awardsSection = document.getElementById("awardsSection");
        if (data.awards.length > 0) {
          document.getElementById("awardsList").innerHTML = data.awards
            .map((a) => `<span class="tag award">üèÜ ${a}</span>`)
            .join("");
          awardsSection.style.display = "block";
        } else {
          awardsSection.style.display = "none";
        }

        // Accents
        const accentsSection = document.getElementById("accentsSection");
        if (data.accents.length > 0) {
          document.getElementById("accentsList").innerHTML = data.accents
            .map((a) => `<span class="tag">${a}</span>`)
            .join("");
          accentsSection.style.display = "block";
        } else {
          accentsSection.style.display = "none";
        }

        // Genres
        const genresSection = document.getElementById("genresSection");
        if (data.genres.length > 0) {
          document.getElementById("genresList").innerHTML = data.genres
            .map((g) => `<span class="tag">${g}</span>`)
            .join("");
          genresSection.style.display = "block";
        } else {
          genresSection.style.display = "none";
        }

        // Books
        const worksSection = document.getElementById("worksSection");
        if (data.books.length > 0) {
          document.getElementById("worksList").innerHTML = data.books
            .map((b) => `<span class="tag">${b}</span>`)
            .join("");
          worksSection.style.display = "block";
        } else {
          worksSection.style.display = "none";
        }

        // Sources
        document.getElementById("sourcesList").innerHTML = data.sources
          .map(
            (s) =>
              `<a href="${s.url}" target="_blank" class="source-link">${
                SOURCES[s.name]?.icon || "üìÑ"
              } ${s.name}</a>`
          )
          .join("");

        // Update export data
        updateExportData();

        resultCard.classList.add("active");
      }

      function selectImage(index) {
        if (!currentData) return;
        currentData.selectedImage = index;

        // Track that user has made a selection (for live updates)
        if (window.userSelectedImage) window.userSelectedImage();

        // Update UI
        document.querySelectorAll(".image-option").forEach((el) => {
          const elIndex = el.dataset.index;
          const isSelected =
            (index === null && elIndex === "none") ||
            (index === "custom" && elIndex === "custom") ||
            (typeof index === "number" && parseInt(elIndex) === index);
          el.classList.toggle("selected", isSelected);
        });

        // Show/hide custom input
        const customInput = document.getElementById("customImageInput");
        customInput.style.display = index === "custom" ? "block" : "none";

        updateExportData();
      }

      function selectBio(index) {
        if (!currentData) return;
        currentData.selectedBio = index;

        // Track that user has made a selection (for live updates)
        if (window.userSelectedBio) window.userSelectedBio();

        // Update UI
        document.querySelectorAll(".bio-option").forEach((el) => {
          const elIndex = el.dataset.index;
          const isSelected =
            (index === null && elIndex === "none") ||
            (index === "custom" && elIndex === "custom") ||
            (typeof index === "number" && parseInt(elIndex) === index);
          el.classList.toggle("selected", isSelected);
          el.querySelector(".bio-option-check").textContent = isSelected
            ? "‚úì"
            : "";
        });

        // Show/hide custom input
        const customInput = document.getElementById("customBioInput");
        customInput.style.display = index === "custom" ? "block" : "none";

        updateExportData();
      }

      function updateExportData() {
        if (!currentData) return;

        let imageUrl = null;
        let imageSource = null;
        let bio = null;
        let bioSource = null;

        // Handle image selection
        if (currentData.selectedImage === "custom") {
          // Check for uploaded image first (stored as base64)
          const uploadedImage = currentData.customImageData;
          const customUrl = document
            .getElementById("customImageUrl")
            ?.value?.trim();

          if (uploadedImage) {
            imageUrl = uploadedImage;
            imageSource = "custom-upload";
          } else if (customUrl) {
            imageUrl = customUrl;
            imageSource = "custom";
          }

          // Update preview
          const preview = document.getElementById("customImagePreview");
          if (preview && (uploadedImage || customUrl)) {
            preview.innerHTML = `<img src="${
              uploadedImage || customUrl
            }" alt="Preview" onerror="this.style.display='none'">`;
          } else if (preview) {
            preview.innerHTML = "";
          }
        } else if (
          currentData.selectedImage !== null &&
          typeof currentData.selectedImage === "number"
        ) {
          const selectedImg = currentData.images[currentData.selectedImage];
          imageUrl = selectedImg?.url || null;
          imageSource = selectedImg?.source || null;
        }

        // Handle bio selection
        if (currentData.selectedBio === "custom") {
          const customBio = document
            .getElementById("customBioText")
            ?.value?.trim();
          if (customBio) {
            bio = customBio;
            bioSource = "custom";
          }
        } else if (
          currentData.selectedBio !== null &&
          typeof currentData.selectedBio === "number"
        ) {
          const selectedBio = currentData.bios[currentData.selectedBio];
          bio = selectedBio?.text || null;
          bioSource = selectedBio?.source || null;
        }

        const exportObj = {
          name: currentData.name,
          imageUrl: imageUrl,
          imageSource: imageSource,
          bio: bio,
          bioSource: bioSource,
          awards: currentData.awards,
          accents: currentData.accents,
          genres: currentData.genres,
          books: currentData.books,
          sources: currentData.sources.map((s) => s.url),
        };

        document.getElementById("exportData").textContent = JSON.stringify(
          exportObj,
          null,
          2
        );
      }

      // Tab switching for custom image input
      function switchImageTab(tab) {
        const urlTab = document.getElementById("imageUrlTab");
        const uploadTab = document.getElementById("imageUploadTab");
        const buttons = document.querySelectorAll(
          ".custom-image-tabs .tab-btn"
        );

        buttons.forEach((btn) => btn.classList.remove("active"));

        if (tab === "url") {
          urlTab.style.display = "block";
          uploadTab.style.display = "none";
          buttons[0].classList.add("active");
          // Clear uploaded image when switching to URL
          if (currentData) {
            currentData.customImageData = null;
          }
        } else {
          urlTab.style.display = "none";
          uploadTab.style.display = "block";
          buttons[1].classList.add("active");
          // Clear URL when switching to upload
          document.getElementById("customImageUrl").value = "";
        }
        updateExportData();
      }

      // File upload handlers
      function handleDragOver(event) {
        event.preventDefault();
        event.stopPropagation();
        event.currentTarget.classList.add("drag-over");
      }

      function handleDragLeave(event) {
        event.preventDefault();
        event.stopPropagation();
        event.currentTarget.classList.remove("drag-over");
      }

      function handleFileDrop(event) {
        event.preventDefault();
        event.stopPropagation();
        event.currentTarget.classList.remove("drag-over");

        const files = event.dataTransfer.files;
        if (files.length > 0) {
          processImageFile(files[0]);
        }
      }

      function handleFileSelect(event) {
        const files = event.target.files;
        if (files.length > 0) {
          processImageFile(files[0]);
        }
      }

      function processImageFile(file) {
        if (!file.type.startsWith("image/")) {
          alert("Please select an image file");
          return;
        }

        // Limit file size to 5MB
        if (file.size > 5 * 1024 * 1024) {
          alert("Image file must be less than 5MB");
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          const base64Data = e.target.result;

          // Store in currentData
          if (currentData) {
            currentData.customImageData = base64Data;
          }

          // Update preview
          const preview = document.getElementById("customImagePreview");
          preview.innerHTML = `<img src="${base64Data}" alt="Uploaded preview">`;

          // Update the upload area to show file name
          const uploadArea = document.getElementById("fileUploadArea");
          uploadArea.innerHTML = `
                    <span class="upload-icon">‚úì</span>
                    <span>${file.name}</span>
                    <small>Click to change</small>
                `;

          updateExportData();
        };
        reader.readAsDataURL(file);
      }

      // Copy button handler
      const copyBtn = document.getElementById("copyBtn");
      if (copyBtn) {
        copyBtn.addEventListener("click", () => {
          const exportText = document.getElementById("exportData").textContent;
          navigator.clipboard.writeText(exportText).then(() => {
            copyBtn.textContent = "Copied!";
            setTimeout(() => (copyBtn.textContent = "Copy JSON"), 2000);
          });
        });
      }

      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.classList.add("active");
        suggestions.style.display = "block";
      }

      // Firebase Functions - Hardcoded config for LitLyric community database
      let firebaseApp = null;
      let firestore = null;
      let storage = null;

      // Hardcoded Firebase configuration
      const FIREBASE_CONFIG = {
        apiKey: "AIzaSyDPKVYX_lPfpPMfwF0ViesSr0YizYZyAX8",
        authDomain: "litlyric-narrator-batabase.firebaseapp.com",
        projectId: "litlyric-narrator-batabase",
        storageBucket: "litlyric-narrator-batabase.firebasestorage.app",
        messagingSenderId: "312216800042",
        appId: "1:312216800042:web:9b90057de27703b4b1ac53",
      };

      const COLLECTION_NAME = "narrators";
      const CHANGE_REQUESTS_COLLECTION = "change_requests";
      const REPORTS_COLLECTION = "reports";

      // Track if current narrator exists in database
      let existingNarratorData = null;

      function toggleFirebaseConfig() {
        // No longer needed - config is hardcoded
      }

      function saveFirebaseConfig() {
        // No longer needed - config is hardcoded
      }

      function loadFirebaseConfig() {
        // Auto-initialize with hardcoded config
        initFirebase();
      }

      function initFirebase() {
        try {
          // Delete existing app if any
          if (firebaseApp) {
            firebaseApp.delete();
          }

          firebaseApp = firebase.initializeApp(FIREBASE_CONFIG);
          firestore = firebase.firestore();
          storage = firebase.storage();

          console.log("Firebase initialized successfully");
          return true;
        } catch (error) {
          console.error("Firebase init error:", error);
          showFirebaseStatus(
            "Failed to initialize Firebase: " + error.message,
            "error"
          );
          return false;
        }
      }

      function showFirebaseStatus(message, type) {
        const status = document.getElementById("firebaseStatus");
        status.textContent = message;
        status.className = "firebase-status show " + type;

        if (type === "success") {
          setTimeout(() => {
            status.classList.remove("show");
          }, 5000);
        }
      }

      async function uploadToFirebase() {
        if (!currentData) {
          showFirebaseStatus("No narrator data to upload", "error");
          return;
        }

        // Initialize Firebase if not already done
        if (!firestore) {
          if (!initFirebase()) {
            return;
          }
        }

        const btn = document.getElementById("firebaseBtn");
        btn.disabled = true;
        btn.classList.add("uploading");
        btn.textContent = "‚è≥ Checking...";

        try {
          // Get selected data
          let imageUrl = null;
          let bio = null;

          if (currentData.selectedImage === "custom") {
            const uploadedImage = currentData.customImageData;
            const customUrl = document
              .getElementById("customImageUrl")
              ?.value?.trim();
            imageUrl = uploadedImage || customUrl;
          } else if (
            currentData.selectedImage !== null &&
            typeof currentData.selectedImage === "number"
          ) {
            const selectedImg = currentData.images[currentData.selectedImage];
            imageUrl = selectedImg?.url;
          }

          if (currentData.selectedBio === "custom") {
            bio = document.getElementById("customBioText")?.value?.trim();
          } else if (
            currentData.selectedBio !== null &&
            typeof currentData.selectedBio === "number"
          ) {
            const selectedBio = currentData.bios[currentData.selectedBio];
            bio = selectedBio?.text;
          }

// Create searchable document ID from name (with international character support)
          const docId = nameToDocId(currentData.name);
          log(`Using document ID: "${docId}" for "${currentData.name}"`, "info");

          // Check if narrator already exists
          const existingDoc = await firestore
            .collection(COLLECTION_NAME)
            .doc(docId)
            .get();

          if (existingDoc.exists) {
            btn.classList.remove("uploading");
            btn.textContent = "üî• Upload to Firebase";
            btn.disabled = false;
            showFirebaseStatus(
              'This narrator already exists. Use "Request Change" to suggest updates.',
              "error"
            );
            return;
          }

          // Upload image to Firebase Storage
          let storedImageUrl = null;

          if (imageUrl && storage) {
            btn.textContent = "‚è≥ Uploading image...";
            showFirebaseStatus("Uploading image to Storage...", "success");

            try {
              const storageRef = storage.ref(`narrator-images/${docId}.jpg`);
              const metadata = { contentType: "image/jpeg" };

              if (imageUrl.startsWith("data:")) {
                // Base64 image - upload directly with metadata
                await storageRef.putString(imageUrl, "data_url", metadata);
                storedImageUrl = await storageRef.getDownloadURL();
              } else {
                // External URL - convert to base64 via canvas, then upload
                try {
                  const base64Data = await fetchImageAsBase64(imageUrl);
                  if (base64Data) {
                    await storageRef.putString(
                      base64Data,
                      "data_url",
                      metadata
                    );
                    storedImageUrl = await storageRef.getDownloadURL();
                  } else {
                    throw new Error("Failed to convert image");
                  }
                } catch (fetchError) {
                  console.log(
                    "Could not fetch/convert image, storing original URL:",
                    fetchError
                  );
                  storedImageUrl = imageUrl;
                }
              }

              log(`Image uploaded to Storage: ${storedImageUrl}`, "success");
            } catch (storageError) {
              console.error("Storage upload error:", storageError);
              showFirebaseStatus(
                "Image upload failed, saving URL reference instead...",
                "error"
              );
              storedImageUrl = imageUrl;
            }
          } else {
            storedImageUrl = imageUrl;
          }

          btn.textContent = "‚è≥ Saving...";
          showFirebaseStatus("Saving to database...", "success");

          // Convert to CDN URL if Cloudflare is configured and image was uploaded to Storage
          let finalImageUrl = storedImageUrl;

          if (
            CLOUDFLARE_WORKER_URL &&
            storedImageUrl &&
            storedImageUrl.includes("firebasestorage.googleapis.com")
          ) {
            // Store CDN URL instead of Firebase URL
            finalImageUrl = `${CLOUDFLARE_WORKER_URL}/narrator-images/${docId}.jpg`;
            log(`Using CDN URL: ${finalImageUrl}`, "success");
          }

          // Simple narrator data
          const narratorData = {
            name: currentData.name,
            imageUrl: finalImageUrl || null,
            bio: bio || null,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          };

          // Add createdAt only if new document
          if (!existingDoc.exists) {
            narratorData.createdAt =
              firebase.firestore.FieldValue.serverTimestamp();
          }

          await firestore
            .collection(COLLECTION_NAME)
            .doc(docId)
            .set(narratorData, { merge: true });

          btn.classList.remove("uploading");
          btn.classList.add("success");
          btn.textContent = "‚úì Uploaded to Database";
          showFirebaseStatus(
            `Successfully saved "${currentData.name}" (ID: ${docId})`,
            "success"
          );

          // Keep success state - don't reset button
        } catch (error) {
          console.error("Upload error:", error);
          btn.classList.remove("uploading");
          btn.classList.add("error");
          btn.textContent = "‚úó Failed";
          showFirebaseStatus("Upload failed: " + error.message, "error");

          setTimeout(() => {
            btn.classList.remove("error");
            btn.textContent = "üî• Upload to Firebase";
            btn.disabled = false;
          }, 3000);
        }
      }

      // Load Firebase config on page load
      document.addEventListener("DOMContentLoaded", () => {
        loadFirebaseConfig();

        // Check for search parameter in URL and auto-search
        const urlParams = new URLSearchParams(window.location.search);
        const searchParam = urlParams.get("search");
        if (searchParam) {
          searchInput.value = searchParam;
          // Small delay to ensure everything is loaded
          setTimeout(() => {
            performSearch();
          }, 500);
        }
      });

      async function generateAIBio() {
        if (!currentData) {
          log("No narrator data available", "error");
          return;
        }

        const btn = document.getElementById("aiGenerateBtn");
        btn.disabled = true;
        btn.classList.add("generating");
        btn.textContent = "üîç Researching...";

        log("Starting AI research with Gemini + Google Search...", "info");

        try {
          // Call our Netlify serverless function
          const response = await fetch("/api/gemini", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              narratorName: currentData.name,
            }),
          });

          btn.textContent = "‚ú® Writing bio...";

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `API error: ${response.status}`);
          }

          const data = await response.json();
          console.log("Gemini Response:", data); // Debug log

          if (!data.bio) {
            throw new Error("No bio generated");
          }

          const bio = data.bio;
          const sources = data.sources || [];

          log(`AI bio generated: ${bio.length} chars`, "success");

          if (data.groundingUsed) {
            log("Google Search grounding was used!", "success");
          }

          if (sources.length > 0) {
            log(`Found ${sources.length} sources`, "info");
            console.log("Sources:", sources);
          }

          // Add to bios list
          const bioEntry = {
            source: "AI Research (Gemini + Google)",
            text: bio,
            length: bio.length,
          };

          if (sources.length > 0) {
            bioEntry.researchSources = sources;
          }

          currentData.bios.unshift(bioEntry);

          // Re-render bio options and select the AI one
          renderBioOptions();
          selectBio(0);

          btn.textContent = "‚úì Generated!";

          if (sources.length > 0) {
            showFirebaseStatus(
              `Bio created from ${sources.length} web sources`,
              "success"
            );
          } else {
            showFirebaseStatus("Bio generated successfully", "success");
          }

          setTimeout(() => {
            btn.textContent = "üîç Research & Generate Bio";
            btn.disabled = false;
            btn.classList.remove("generating");
          }, 2000);
        } catch (error) {
          log(`AI research failed: ${error.message}`, "error");
          console.error("Gemini API Error:", error);

          btn.textContent = "‚úó Failed";

          // Show helpful error message
          let errorMsg = error.message;
          if (error.message.includes("GEMINI_API_KEY")) {
            errorMsg =
              "Gemini API key not configured. Add GEMINI_API_KEY to Netlify environment variables.";
          } else if (
            error.message.includes("quota") ||
            error.message.includes("limit") ||
            error.message.includes("429")
          ) {
            errorMsg = "API quota exceeded. Try again later.";
          } else if (
            error.message.includes("blocked") ||
            error.message.includes("safety")
          ) {
            errorMsg = "Content was blocked by safety filters.";
          }

          showFirebaseStatus(errorMsg, "error");

          setTimeout(() => {
            btn.textContent = "üîç Research & Generate Bio";
            btn.disabled = false;
            btn.classList.remove("generating");
          }, 3000);
        }
      }

      // Re-render bio options (used after AI generation)
      function renderBioOptions() {
        const bioOptionsEl = document.getElementById("bioOptions");
        if (!currentData || !currentData.bios) return;

        let biosHtml = "";
        currentData.bios.forEach((bio, index) => {
          const isSelected = currentData.selectedBio === index;
          const isAI = bio.source === "AI Generated";
          biosHtml += `
                    <div class="bio-option ${isSelected ? "selected" : ""}" 
                         onclick="selectBio(${index})" 
                         data-index="${index}"
                         style="${
                           isAI
                             ? "border-color: #667eea; background: rgba(102, 126, 234, 0.1);"
                             : ""
                         }">
                        <div class="bio-option-header">
                            <span class="bio-source">${isAI ? "‚ú® " : ""}${
            bio.source
          }</span>
                            <span class="bio-length">${bio.length} chars</span>
                        </div>
                        <div class="bio-option-text">${bio.text}</div>
                        <div class="bio-option-check">‚úì</div>
                    </div>
                `;
        });

        if (biosHtml === "") {
          biosHtml =
            '<p style="color: #6b7280; text-align: center;">No biographies found. Try the AI generator above!</p>';
        }

        bioOptionsEl.innerHTML = biosHtml;
      }

      // Timeout wrapper for fetch operations
      function fetchWithTimeout(promise, timeoutMs = 30000) {
        return Promise.race([
          promise,
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error("Timeout")), timeoutMs)
          ),
        ]);
      }

      // Check if narrator exists in Firebase database
      async function checkExistingNarrator(name) {
        if (!firestore) {
          log("Firebase not initialized, attempting init...", "warning");
          if (!initFirebase()) {
            log("Firebase init failed", "error");
            return null;
          }
        }

        const docId = nameToDocId(name);

        log(`Looking up document ID: "${docId}"`, "info");

        try {
          const doc = await firestore
            .collection(COLLECTION_NAME)
            .doc(docId)
            .get();
          if (doc.exists) {
            log(`Found "${name}" in database`, "success");
            return { id: docId, ...doc.data() };
          } else {
            log(`Document "${docId}" not found in database`, "info");
          }
        } catch (error) {
          log(`Error checking database: ${error.message}`, "error");
        }
        return null;
      }

      // Display existing narrator profile
      function displayExistingProfile(data, searchName) {
        existingNarratorData = data;

        const card = document.getElementById("existingProfileCard");
        const img = document.getElementById("existingImage");
        const noImg = document.getElementById("existingNoImage");
        const name = document.getElementById("existingNarratorName");
        const bio = document.getElementById("existingBio");
        const noBio = document.getElementById("existingNoBio");

        // Set name
        name.textContent = data.name || searchName;

        // Set image
        if (data.imageUrl) {
          img.src = getCdnImageUrl(data.imageUrl);
          img.style.display = "block";
          noImg.style.display = "none";
        } else {
          img.style.display = "none";
          noImg.style.display = "flex";
        }

        // Set bio
        if (data.bio) {
          bio.textContent = data.bio;
          bio.style.display = "block";
          noBio.style.display = "none";
        } else {
          bio.style.display = "none";
          noBio.style.display = "block";
        }

        card.style.display = "block";
        log("Displaying existing profile from database", "success");
      }

      // Start change request - runs the normal search
      function startChangeRequest() {
        log("Starting change request - searching external sources...", "info");
        document.getElementById("existingProfileCard").style.display = "none";

        // Run search but skip database check
        performSearch(true);
      }

      // Modal functions
      function showRequestChangeModal() {
        // This modal asks for optional reason/email before submitting
        document.getElementById("requestChangeModal").style.display = "flex";
      }

      function closeRequestChangeModal() {
        document.getElementById("requestChangeModal").style.display = "none";
        document.getElementById("changeReason").value = "";
        document.getElementById("changeEmail").value = "";
      }

      function showReportModal() {
        document.getElementById("reportModal").style.display = "flex";
      }

      function closeReportModal() {
        document.getElementById("reportModal").style.display = "none";
        // Reset form
        document
          .querySelectorAll('input[name="reportReason"]')
          .forEach((r) => (r.checked = false));
        document.getElementById("reportDetails").value = "";
        document.getElementById("reportEmail").value = "";
      }

      // Submit change request - uses currently selected image/bio
      async function submitChangeRequest() {
        if (!currentData || !existingNarratorData) {
          showFirebaseStatus("No data to submit", "error");
          return;
        }

        const reason = document.getElementById("changeReason").value.trim();
        const email = document.getElementById("changeEmail").value.trim();

        if (!firestore) {
          if (!initFirebase()) return;
        }

        const btn = document.querySelector("#requestChangeModal .modal-submit");
        btn.disabled = true;
        btn.textContent = "Submitting...";

        try {
          // Get selected data
          let newImageUrl = null;
          let newBio = null;

          // Debug logging
          log(`Selected image index: ${currentData.selectedImage}`, "info");
          log(`Selected bio index: ${currentData.selectedBio}`, "info");

          // Handle image selection
          if (currentData.selectedImage === "custom") {
            newImageUrl =
              currentData.customImageData ||
              document.getElementById("customImageUrl")?.value?.trim();
            log(`Custom image URL: ${newImageUrl ? "yes" : "no"}`, "info");
          } else if (
            typeof currentData.selectedImage === "number" &&
            currentData.selectedImage >= 0
          ) {
            newImageUrl = currentData.images[currentData.selectedImage]?.url;
            log(
              `Image from index ${currentData.selectedImage}: ${
                newImageUrl ? newImageUrl.substring(0, 50) + "..." : "none"
              }`,
              "info"
            );
          }

          // Handle bio selection
          if (currentData.selectedBio === "custom") {
            newBio = document.getElementById("customBioText")?.value?.trim();
          } else if (
            typeof currentData.selectedBio === "number" &&
            currentData.selectedBio >= 0
          ) {
            newBio = currentData.bios[currentData.selectedBio]?.text;
          }

          // Warn if nothing selected
          if (!newImageUrl && !newBio) {
            showFirebaseStatus(
              "Please select an image or bio to submit",
              "error"
            );
            btn.disabled = false;
            btn.textContent = "Submit for Review";
            return;
          }

          log(
            `Submitting - Image: ${newImageUrl ? "yes" : "no"}, Bio: ${
              newBio ? "yes" : "no"
            }`,
            "info"
          );

          const changeRequest = {
            narratorId: existingNarratorData.id,
            narratorName: currentData.name,
            currentData: {
              imageUrl: existingNarratorData.imageUrl || null,
              bio: existingNarratorData.bio || null,
            },
            proposedChanges: {
              imageUrl: newImageUrl || null,
              bio: newBio || null,
            },
            reason: reason || null,
            submitterEmail: email || null,
            status: "pending",
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          };

          await firestore
            .collection(CHANGE_REQUESTS_COLLECTION)
            .add(changeRequest);

          btn.textContent = "‚úì Submitted!";
          showFirebaseStatus("Change request submitted for review!", "success");
          log("Change request submitted successfully", "success");

          setTimeout(() => {
            closeRequestChangeModal();
            btn.disabled = false;
            btn.textContent = "Submit Request";
          }, 2000);
        } catch (error) {
          console.error("Submit error:", error);
          btn.textContent = "Failed";
          showFirebaseStatus("Failed to submit: " + error.message, "error");

          setTimeout(() => {
            btn.disabled = false;
            btn.textContent = "Submit Request";
          }, 2000);
        }
      }

      // Submit report
      async function submitReport() {
        if (!existingNarratorData) {
          showFirebaseStatus("No narrator data to report", "error");
          return;
        }

        const reasonEl = document.querySelector(
          'input[name="reportReason"]:checked'
        );
        const details = document.getElementById("reportDetails").value.trim();
        const email = document.getElementById("reportEmail").value.trim();

        if (!reasonEl) {
          alert("Please select a reason for the report.");
          return;
        }

        if (!firestore) {
          if (!initFirebase()) return;
        }

        const btn = document.querySelector("#reportModal .modal-submit");
        btn.disabled = true;
        btn.textContent = "Submitting...";

        try {
          const report = {
            narratorId: existingNarratorData.id,
            narratorName: existingNarratorData.name || "Unknown",
            currentData: {
              imageUrl: existingNarratorData.imageUrl || null,
              bio: existingNarratorData.bio || null,
            },
            reason: reasonEl.value,
            details: details || null,
            submitterEmail: email || null,
            status: "pending",
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          };

          await firestore.collection(REPORTS_COLLECTION).add(report);

          btn.textContent = "‚úì Reported!";
          showFirebaseStatus(
            "Report submitted. Thank you for helping keep the database accurate!",
            "success"
          );
          log("Report submitted successfully", "success");

          setTimeout(() => {
            closeReportModal();
            btn.disabled = false;
            btn.textContent = "Submit Report";
          }, 2000);
        } catch (error) {
          console.error("Report error:", error);
          btn.textContent = "Failed";
          showFirebaseStatus(
            "Failed to submit report: " + error.message,
            "error"
          );

          setTimeout(() => {
            btn.disabled = false;
            btn.textContent = "Submit Report";
          }, 2000);
        }
      }

      // Close modals when clicking outside
      document
        .getElementById("requestChangeModal")
        ?.addEventListener("click", (e) => {
          if (e.target.id === "requestChangeModal") closeRequestChangeModal();
        });

      document.getElementById("reportModal")?.addEventListener("click", (e) => {
        if (e.target.id === "reportModal") closeReportModal();
      });
    </script>
  </body>
</html>
