<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The LitLyric Narrator Project</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #0d2137 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
            padding: 2rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .header-logo {
            width: 80px;
            height: 80px;
            margin-bottom: 1rem;
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, #0066FF, #00AAFF);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #8892a0;
        }

        .version-badge {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.2rem 0.8rem;
            font-size: 0.7rem;
            color: #6b7280;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            letter-spacing: 1px;
        }

        .request-change-btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .request-change-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }

        .report-btn {
            padding: 0.75rem 1.5rem;
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            border-radius: 8px;
            color: #f87171;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .report-btn:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        /* Existing Profile Card */
        .existing-profile-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            margin-top: 1rem;
            animation: fadeIn 0.5s ease;
        }

        .existing-profile-header {
            display: flex;
            align-items: center;
            gap: 2rem;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.2);
        }

        .existing-profile-image {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.05);
        }

        .existing-profile-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .no-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
            font-size: 0.9rem;
        }

        .existing-profile-info {
            flex: 1;
        }

        .database-badge {
            display: inline-block;
            background: linear-gradient(135deg, #0066FF, #00AAFF);
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .existing-profile-info h2 {
            font-size: 2rem;
            font-weight: 600;
            color: #fff;
            margin: 0;
        }

        .existing-profile-bio {
            padding: 2rem;
        }

        .existing-profile-bio h3 {
            color: #00AAFF;
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .existing-profile-bio p {
            color: #ccc;
            line-height: 1.7;
            font-size: 0.95rem;
        }

        .existing-profile-actions {
            display: flex;
            gap: 1rem;
            padding: 1.5rem 2rem;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 600px) {
            .existing-profile-header {
                flex-direction: column;
                text-align: center;
            }
            
            .existing-profile-actions {
                flex-direction: column;
            }
            
            .existing-profile-actions button {
                width: 100%;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content h3 {
            margin-bottom: 0.5rem;
            color: #fff;
        }

        .modal-content > p {
            color: #8892a0;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
        }

        .modal-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .modal-form label {
            color: #ccc;
            font-size: 0.9rem;
        }

        .modal-form textarea,
        .modal-form input[type="email"] {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.75rem;
            color: #fff;
            font-size: 0.9rem;
            resize: vertical;
        }

        .modal-form textarea {
            min-height: 80px;
        }

        .modal-form textarea:focus,
        .modal-form input:focus {
            outline: none;
            border-color: #0066FF;
        }

        .checkbox-group,
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.5rem 0;
        }

        .checkbox-group label,
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            color: #aaa;
        }

        .checkbox-group input,
        .radio-group input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .modal-cancel {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-cancel:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .modal-submit {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-submit:hover {
            transform: translateY(-2px);
        }

        .modal-submit.report {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .modal-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .search-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .search-input {
            flex: 1;
            padding: 1rem 1.5rem;
            font-size: 1.1rem;
            border: none;
            border-radius: 50px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            outline: none;
        }

        .search-input::placeholder {
            color: #6b7280;
        }

        .search-input:focus {
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(0, 102, 255, 0.3);
        }

        .search-btn {
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            background: linear-gradient(135deg, #0066FF, #00AAFF);
            color: #fff;
            cursor: pointer;
        }

        .search-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 102, 255, 0.4);
        }

        .search-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 3rem;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #0066FF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .source-progress {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .source-status {
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            color: #6b7280;
        }

        .source-status.searching {
            background: rgba(0, 102, 255, 0.2);
            color: #0066FF;
            animation: pulse 1.5s infinite;
        }

        .source-status.found {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .source-status.not-found {
            background: rgba(239, 68, 68, 0.1);
            color: #6b7280;
            text-decoration: line-through;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .result-card {
            display: none;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .result-card.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .profile-header {
            display: flex;
            gap: 2rem;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.2);
        }

        .profile-image {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid rgba(0, 102, 255, 0.5);
            background: rgba(255, 255, 255, 0.1);
        }

        .profile-placeholder {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 4px solid rgba(0, 102, 255, 0.5);
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
        }

        .profile-info {
            flex: 1;
        }

        .narrator-name {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .narrator-tagline {
            color: #00AAFF;
            font-style: italic;
            margin-bottom: 1rem;
        }

        .source-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .source-badge {
            padding: 0.25rem 0.75rem;
            background: rgba(0, 102, 255, 0.2);
            border-radius: 20px;
            font-size: 0.75rem;
            color: #0066FF;
        }

        .profile-body {
            padding: 2rem;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #00AAFF;
        }

        .bio-text {
            line-height: 1.8;
            color: #c8c8c8;
            white-space: pre-line;
        }

        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .tag {
            padding: 0.4rem 0.8rem;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            font-size: 0.85rem;
            color: #a8a8a8;
        }

        .tag.award {
            background: rgba(245, 166, 35, 0.15);
            color: #00AAFF;
        }

        .sources-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sources-section h4 {
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
            color: #6b7280;
        }

        .sources-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .source-link {
            padding: 0.4rem 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 0.8rem;
            color: #8892a0;
            text-decoration: none;
        }

        .source-link:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #0066FF;
        }

        /* Selection sections */
        .selection-section {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .selection-section h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #00AAFF;
        }

        .image-options {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .image-option {
            position: relative;
            cursor: pointer;
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .image-option:hover {
            border-color: rgba(0, 102, 255, 0.5);
        }

        .image-option.selected {
            border-color: #0066FF;
            box-shadow: 0 0 20px rgba(0, 102, 255, 0.4);
        }

        .image-option img {
            width: 120px;
            height: 120px;
            object-fit: cover;
            display: block;
        }

        .image-option-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 0.5rem;
            font-size: 0.7rem;
        }

        .image-option-source {
            color: #00AAFF;
            font-weight: 600;
        }

        .image-option-score {
            color: #888;
        }

        .image-option-check {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: #0066FF;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .image-option.selected .image-option-check {
            display: flex;
        }

        .bio-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .ai-generate-btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .ai-generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .ai-generate-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .ai-generate-btn.generating {
            background: linear-gradient(135deg, #00AAFF, #0066FF);
        }

        .fast-mode-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            color: #8892a0;
            margin-left: 1rem;
        }

        .fast-mode-toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .bio-option {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .bio-option:hover {
            border-color: rgba(0, 102, 255, 0.3);
            background: rgba(255, 255, 255, 0.08);
        }

        .bio-option.selected {
            border-color: #0066FF;
            background: rgba(0, 102, 255, 0.1);
        }

        .bio-option-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .bio-option-source {
            color: #00AAFF;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .bio-option-length {
            color: #666;
            font-size: 0.75rem;
        }

        .bio-option-text {
            color: #c8c8c8;
            font-size: 0.9rem;
            line-height: 1.6;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .bio-option.selected .bio-option-text {
            -webkit-line-clamp: unset;
        }

        .bio-option-check {
            width: 20px;
            height: 20px;
            border: 2px solid #666;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .bio-option.selected .bio-option-check {
            background: #0066FF;
            border-color: #0066FF;
            color: white;
        }

        /* Export section */
        .export-section {
            padding: 1.5rem 2rem;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .export-section h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #00AAFF;
        }

        #exportData {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.75rem;
            color: #a8a8a8;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
        }

        .export-btn {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #0066FF, #00AAFF);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 102, 255, 0.4);
        }

        .firebase-btn {
            margin-top: 1rem;
            margin-left: 1rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .firebase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
        }

        .firebase-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .firebase-btn.uploading {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .firebase-btn.success {
            background: linear-gradient(135deg, #4CAF50, #2e7d32);
        }

        .firebase-btn.error {
            background: linear-gradient(135deg, #f44336, #c62828);
        }

        .firebase-config {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            display: none;
        }

        .firebase-config.show {
            display: block;
        }

        .firebase-config label {
            display: block;
            margin-bottom: 0.25rem;
            color: #00AAFF;
            font-size: 0.85rem;
        }

        .firebase-config input {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            font-size: 0.85rem;
        }

        .firebase-config input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .firebase-status {
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.85rem;
            display: none;
        }

        .firebase-status.show {
            display: block;
        }

        .firebase-status.success {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
        }

        .firebase-status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #e57373;
        }

        .config-toggle {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
            text-decoration: underline;
            margin-top: 0.5rem;
        }

        .config-toggle:hover {
            color: #00AAFF;
        }

        .no-options {
            color: #666;
            font-style: italic;
            padding: 1rem;
        }

        .no-image-option {
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            color: #888;
        }

        .no-image-option span {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .no-image-option small {
            font-size: 0.75rem;
        }

        .custom-image-option {
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 102, 255, 0.1);
            color: #0066FF;
            border: 2px dashed rgba(0, 102, 255, 0.3);
            border-radius: 8px;
        }

        .custom-image-option span {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .custom-image-option small {
            font-size: 0.75rem;
        }

        .custom-input-container {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(0, 102, 255, 0.3);
        }

        .custom-input-container label {
            display: block;
            margin-bottom: 0.5rem;
            color: #00AAFF;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .custom-input-container input,
        .custom-input-container textarea {
            width: 100%;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-family: inherit;
        }

        .custom-input-container input:focus,
        .custom-input-container textarea:focus {
            outline: none;
            border-color: #0066FF;
        }

        .custom-input-container textarea {
            resize: vertical;
            min-height: 100px;
        }

        .custom-image-preview {
            margin-top: 0.75rem;
        }

        .custom-image-preview img {
            max-width: 150px;
            max-height: 150px;
            border-radius: 8px;
            object-fit: cover;
        }

        .custom-image-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .tab-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .tab-btn.active {
            background: rgba(0, 102, 255, 0.2);
            border-color: #0066FF;
            color: #0066FF;
        }

        .image-tab-content {
            margin-bottom: 0.5rem;
        }

        .file-upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            color: #888;
        }

        .file-upload-area:hover,
        .file-upload-area.drag-over {
            border-color: #0066FF;
            background: rgba(0, 102, 255, 0.1);
            color: #0066FF;
        }

        .file-upload-area .upload-icon {
            font-size: 2rem;
        }

        .file-upload-area small {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .error-message {
            display: none;
            text-align: center;
            padding: 2rem;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #f87171;
        }

        .error-message.active {
            display: block;
        }

        .suggestions {
            margin-top: 2rem;
            text-align: center;
        }

        .suggestions p {
            color: #6b7280;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .suggestion-chips {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
        }

        .suggestion-chip {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 0.85rem;
            color: #a8a8a8;
            cursor: pointer;
        }

        .suggestion-chip:hover {
            background: rgba(0, 102, 255, 0.2);
            border-color: rgba(0, 102, 255, 0.4);
            color: #00AAFF;
        }

        /* Debug panel */
        .debug-panel {
            margin-top: 2rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.75rem;
            color: #6b7280;
            max-height: 300px;
            overflow-y: auto;
        }

        .debug-panel h4 {
            color: #00AAFF;
            margin-bottom: 0.5rem;
        }

        .debug-entry {
            margin: 0.25rem 0;
            padding: 0.25rem;
            border-left: 2px solid #333;
            padding-left: 0.5rem;
        }

        .debug-entry.success {
            border-color: #22c55e;
        }

        .debug-entry.error {
            border-color: #ef4444;
        }

        @media (max-width: 600px) {
            .search-container {
                flex-direction: column;
            }
            .profile-header {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="logo.png" alt="LitLyric Logo" class="header-logo">
            <h1>The LitLyric Narrator Project</h1>
            <p class="subtitle">Search multiple sources for audiobook narrator profiles</p>
            <span class="version-badge">v1.6.9</span>
        </header>

        <div class="search-container">
            <input type="text" class="search-input" id="narratorInput" 
                   placeholder="Enter narrator name (e.g., Simon Vance)" autocomplete="off">
            <button class="search-btn" id="searchBtn">Search</button>
            <label class="fast-mode-toggle" title="Skip slower sources (SoundCloud, Soundbooth, etc.)">
                <input type="checkbox" id="fastModeToggle"> Fast
            </label>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Searching narrator databases...</p>
            <div class="source-progress" id="sourceProgress"></div>
        </div>

        <div class="error-message" id="errorMessage"></div>

        <!-- Existing Narrator Profile (shown when found in database) -->
        <div class="existing-profile-card" id="existingProfileCard" style="display: none;">
            <div class="existing-profile-header">
                <div class="existing-profile-image" id="existingProfileImage">
                    <img src="" alt="" id="existingImage">
                    <div class="no-image-placeholder" id="existingNoImage" style="display: none;">
                        <span>No Photo</span>
                    </div>
                </div>
                <div class="existing-profile-info">
                    <span class="database-badge">‚úì In LitLyric Database</span>
                    <h2 id="existingNarratorName"></h2>
                </div>
            </div>
            
            <div class="existing-profile-bio">
                <h3>About</h3>
                <p id="existingBio"></p>
                <p id="existingNoBio" style="display: none; color: #6b7280; font-style: italic;">No biography available.</p>
            </div>
            
            <div class="existing-profile-actions">
                <button class="request-change-btn" onclick="startChangeRequest()">
                    ‚úèÔ∏è Request Change
                </button>
                <button class="report-btn" onclick="showReportModal()">
                    üö© Report Issue
                </button>
            </div>
        </div>

        <!-- Search Results Card (shown for new narrators or when editing) -->
        <div class="result-card" id="resultCard">
            <div class="profile-header">
                <div class="profile-info-header">
                    <h2 class="narrator-name" id="narratorName"></h2>
                    <p class="narrator-tagline" id="narratorTagline"></p>
                    <div class="source-badges" id="sourceBadges"></div>
                </div>
            </div>
            
            <!-- Image Selection Section -->
            <div class="selection-section" id="imageSelectionSection">
                <h3>üì∑ Select Profile Image</h3>
                <div class="image-options" id="imageOptions"></div>
                <div class="custom-input-container" id="customImageInput" style="display: none;">
                    <label>Custom Image:</label>
                    <div class="custom-image-tabs">
                        <button type="button" class="tab-btn active" onclick="switchImageTab('url')">URL</button>
                        <button type="button" class="tab-btn" onclick="switchImageTab('upload')">Upload</button>
                    </div>
                    <div id="imageUrlTab" class="image-tab-content">
                        <input type="text" id="customImageUrl" placeholder="https://example.com/image.jpg" 
                               oninput="updateExportData()">
                    </div>
                    <div id="imageUploadTab" class="image-tab-content" style="display: none;">
                        <div class="file-upload-area" id="fileUploadArea" 
                             onclick="document.getElementById('imageFileInput').click()"
                             ondragover="handleDragOver(event)" 
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleFileDrop(event)">
                            <span class="upload-icon">üìÅ</span>
                            <span>Click to upload or drag & drop</span>
                            <small>JPG, PNG, GIF, WebP</small>
                        </div>
                        <input type="file" id="imageFileInput" accept="image/*" 
                               style="display: none;" onchange="handleFileSelect(event)">
                    </div>
                    <div class="custom-image-preview" id="customImagePreview"></div>
                </div>
            </div>
            
            <!-- Bio Selection Section -->
            <div class="selection-section" id="bioSelectionSection">
                <h3>üìù Select Biography</h3>
                <div class="bio-options" id="bioOptions"></div>
                <div class="custom-input-container" id="customBioInput" style="display: none;">
                    <label>Custom Biography:</label>
                    <textarea id="customBioText" placeholder="Write a custom biography..." 
                              rows="4" oninput="updateExportData()"></textarea>
                </div>
                
                <!-- AI Bio Generation -->
                <div class="ai-bio-section" id="aiBioSection" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                    <button class="ai-generate-btn" id="aiGenerateBtn" onclick="generateAIBio()">
                        ‚ú® Generate Bio with AI
                    </button>
                    <p style="font-size: 0.75rem; color: #6b7280; margin-top: 0.5rem;">
                        Uses AI to create a professional narrator bio from available information
                    </p>
                </div>
            </div>

            <div class="profile-body">
                <div class="section" id="awardsSection">
                    <h3>üèÜ Awards</h3>
                    <div class="tags-list" id="awardsList"></div>
                </div>

                <div class="section" id="accentsSection">
                    <h3>üó£Ô∏è Accents</h3>
                    <div class="tags-list" id="accentsList"></div>
                </div>

                <div class="section" id="genresSection">
                    <h3>üé≠ Genres</h3>
                    <div class="tags-list" id="genresList"></div>
                </div>
                
                <div class="section" id="worksSection">
                    <h3>üìö Notable Audiobooks</h3>
                    <div class="tags-list" id="worksList"></div>
                </div>

                <div class="sources-section">
                    <h4>Sources</h4>
                    <div class="sources-list" id="sourcesList"></div>
                </div>
            </div>
            
            <!-- Export Section -->
            <div class="export-section">
                <h3>üì§ Selected Data</h3>
                <pre id="exportData"></pre>
                
                <!-- Buttons for NEW narrators (not in database) -->
                <div id="newNarratorButtons" style="display: flex; flex-wrap: wrap; align-items: center;">
                    <button class="export-btn" id="copyBtn">Copy JSON</button>
                    <button class="firebase-btn" id="firebaseBtn" onclick="uploadToFirebase()">
                        üî• Upload to Firebase
                    </button>
                </div>
                
                <!-- Buttons for EXISTING narrators (already in database) -->
                <div id="existingNarratorButtons" style="display: none; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
                    <button class="export-btn" id="copyBtn2" onclick="copyJson()">Copy JSON</button>
                    <button class="request-change-btn" id="requestChangeBtn" onclick="showRequestChangeModal()">
                        üì§ Submit Change Request
                    </button>
                </div>
                
                <div class="firebase-status" id="firebaseStatus"></div>
                <p style="font-size: 0.75rem; color: #6b7280; margin-top: 0.5rem; text-align: center;">
                    Community database - uploads are shared with all LitLyric users
                </p>
            </div>
        </div>
        
        <!-- Request Change Modal -->
        <div class="modal-overlay" id="requestChangeModal" style="display: none;">
            <div class="modal-content">
                <h3>‚úèÔ∏è Submit Change Request</h3>
                <p>Your selected image and bio will be submitted for review. An admin will approve the changes before they go live.</p>
                
                <div class="modal-form">
                    <label>Reason for change (optional):</label>
                    <textarea id="changeReason" placeholder="e.g., Found a better quality photo, bio has incorrect information, more detailed bio available..."></textarea>
                    
                    <label>Your email (optional, for follow-up):</label>
                    <input type="email" id="changeEmail" placeholder="your@email.com">
                </div>
                
                <div class="modal-buttons">
                    <button class="modal-cancel" onclick="closeRequestChangeModal()">Cancel</button>
                    <button class="modal-submit" onclick="submitChangeRequest()">Submit for Review</button>
                </div>
            </div>
        </div>
        
        <!-- Report Modal -->
        <div class="modal-overlay" id="reportModal" style="display: none;">
            <div class="modal-content">
                <h3>üö© Report Issue</h3>
                <p>Report a problem with this narrator entry.</p>
                
                <div class="modal-form">
                    <label>Reason for report:</label>
                    <div class="radio-group">
                        <label><input type="radio" name="reportReason" value="wrong_person"> Wrong person / Incorrect identity</label>
                        <label><input type="radio" name="reportReason" value="inappropriate"> Inappropriate content</label>
                        <label><input type="radio" name="reportReason" value="copyright"> Copyright issue</label>
                        <label><input type="radio" name="reportReason" value="outdated"> Severely outdated information</label>
                        <label><input type="radio" name="reportReason" value="spam"> Spam or fake entry</label>
                        <label><input type="radio" name="reportReason" value="other"> Other</label>
                    </div>
                    
                    <label>Additional details:</label>
                    <textarea id="reportDetails" placeholder="Please describe the issue..."></textarea>
                    
                    <label>Your email (optional, for follow-up):</label>
                    <input type="email" id="reportEmail" placeholder="your@email.com">
                </div>
                
                <div class="modal-buttons">
                    <button class="modal-cancel" onclick="closeReportModal()">Cancel</button>
                    <button class="modal-submit report" onclick="submitReport()">Submit Report</button>
                </div>
            </div>
        </div>

        <div class="suggestions" id="suggestions">
            <p>Try searching for popular narrators:</p>
            <div class="suggestion-chips">
                <span class="suggestion-chip" data-narrator="Simon Vance">Simon Vance</span>
                <span class="suggestion-chip" data-narrator="Jim Dale">Jim Dale</span>
                <span class="suggestion-chip" data-narrator="Scott Brick">Scott Brick</span>
                <span class="suggestion-chip" data-narrator="Julia Whelan">Julia Whelan</span>
                <span class="suggestion-chip" data-narrator="Ray Porter">Ray Porter</span>
                <span class="suggestion-chip" data-narrator="Andrea Parsneau">Andrea Parsneau</span>
                <span class="suggestion-chip" data-narrator="Travis Baldree">Travis Baldree</span>
                <span class="suggestion-chip" data-narrator="RC Bray">RC Bray</span>
                <span class="suggestion-chip" data-narrator="Stephen Fry">Stephen Fry</span>
                <span class="suggestion-chip" data-narrator="Nick Podehl">Nick Podehl</span>
            </div>
        </div>

        <div class="debug-panel" id="debugPanel">
            <h4>Debug Log</h4>
            <div id="debugLog"></div>
        </div>
    </div>

    <script>
        // Source configurations
        const SOURCES = {
            audible: {
                name: 'Audible',
                icon: 'üéß',
                getUrl: (name) => `https://www.audible.com/ep/narrator-${nameToSlug(name)}`
            },
            wikipedia: {
                name: 'Wikipedia',
                icon: 'üìñ',
                getUrl: (name) => `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(name.replace(/ /g, '_'))}`
            },
            audiofile: {
                name: 'AudioFile',
                icon: 'üì∞',
                getUrl: (name) => `https://www.audiofilemagazine.com/narrators/${nameToSlug(name)}/`
            },
            voicestoknow: {
                name: 'Voices to Know',
                icon: 'üé§',
                getUrl: (name) => `https://voicestoknow.com/talent/${nameToSlug(name)}/`
            },
            soundbooth: {
                name: 'Soundbooth',
                icon: 'üé≠',
                getUrl: (name) => `https://soundbooththeater.com/team/${nameToSlug(name)}/`
            },
            soundcloud: {
                name: 'SoundCloud',
                icon: '‚òÅÔ∏è',
                getUrl: (name) => `https://soundcloud.com/${name.toLowerCase().replace(/[^a-z0-9]/g, '')}`
            },
            personalsite: {
                name: 'Personal Site',
                icon: 'üåê',
                getUrl: (name) => null // Dynamic
            },
            tantor: {
                name: 'Tantor',
                icon: 'üìö',
                getUrl: (name) => `https://tantor.com/narrator/${nameToSlug(name)}.html`
            },
            imdb: {
                name: 'IMDB',
                icon: 'üé¨',
                getUrl: (name) => `https://www.imdb.com/find/?q=${encodeURIComponent(name)}&s=nm`
            },
            google: {
                name: 'Google',
                icon: 'üîç',
                getUrl: (name) => `https://www.google.com/search?q=${encodeURIComponent(name + ' audiobook narrator')}`
            }
        };

        const searchInput = document.getElementById('narratorInput');
        const searchBtn = document.getElementById('searchBtn');
        const loading = document.getElementById('loading');
        const resultCard = document.getElementById('resultCard');
        const errorMessage = document.getElementById('errorMessage');
        const suggestions = document.getElementById('suggestions');
        const sourceProgress = document.getElementById('sourceProgress');
        const debugLog = document.getElementById('debugLog');

        // Event listeners
        document.querySelectorAll('.suggestion-chip').forEach(chip => {
            chip.addEventListener('click', () => {
                searchInput.value = chip.dataset.narrator;
                performSearch();
            });
        });

        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') performSearch();
        });

        searchBtn.addEventListener('click', performSearch);

        function nameToSlug(name) {
            return name.toLowerCase()
                .replace(/[^a-z0-9\s\-]/g, '')  // Keep hyphens
                .replace(/\s+/g, '-')            // Replace spaces with hyphens
                .replace(/--+/g, '-')            // Replace multiple hyphens with single
                .trim();
        }
        
        // Generate slug variant with periods expanded (RC -> r-c)
        function nameToSlugExpanded(name) {
            return name.toLowerCase()
                .split(/\s+/)
                .map(word => {
                    // If word is 2-3 letters and all same case, expand initials
                    if (word.length <= 3 && /^[a-z]+$/.test(word)) {
                        return word.split('').join('-');
                    }
                    return word;
                })
                .join('-')
                .replace(/[^a-z0-9\-]/g, '')
                .replace(/--+/g, '-')
                .trim();
        }

        // Helper function to fetch an image URL and convert to base64
        // Uses an img element and canvas to handle CORS and ensure proper image data
        function fetchImageAsBase64(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = function() {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        // Convert to JPEG base64
                        const base64 = canvas.toDataURL('image/jpeg', 0.9);
                        resolve(base64);
                    } catch (e) {
                        reject(e);
                    }
                };
                
                img.onerror = function() {
                    // If direct load fails (CORS), try via proxy
                    const proxyImg = new Image();
                    proxyImg.crossOrigin = 'anonymous';
                    
                    proxyImg.onload = function() {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = proxyImg.naturalWidth;
                            canvas.height = proxyImg.naturalHeight;
                            
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(proxyImg, 0, 0);
                            
                            const base64 = canvas.toDataURL('image/jpeg', 0.9);
                            resolve(base64);
                        } catch (e) {
                            reject(e);
                        }
                    };
                    
                    proxyImg.onerror = function() {
                        reject(new Error('Failed to load image'));
                    };
                    
                    // Try a CORS proxy
                    proxyImg.src = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                };
                
                img.src = url;
            });
        }

        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `debug-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugLog.appendChild(entry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function updateSourceStatus(sourceKey, status) {
            const el = document.getElementById(`status-${sourceKey}`);
            if (el) {
                el.className = `source-status ${status}`;
            }
        }

        async function fetchViaProxy(url) {
            // Try multiple CORS proxies in case one fails
            const corsProxies = [
                (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`,
                (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
                (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`
            ];
            
            for (const proxyFn of corsProxies) {
                try {
                    const proxyUrl = proxyFn(url);
                    const response = await fetch(proxyUrl);
                    if (response.ok) {
                        return await response.text();
                    }
                } catch (e) {
                    // Try next proxy
                    continue;
                }
            }
            throw new Error('All CORS proxies failed');
        }

        // Strip HTML tags
        function stripHtml(html) {
            return html
                .replace(/<[^>]*>/g, '')
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&quot;/g, '"')
                .replace(/&#x27;/g, "'")
                .replace(/&nbsp;/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        // Clean bio text - remove narrator name from the start if present
        function cleanBio(bio, name) {
            if (!bio || !name) return bio;
            
            let cleanedBio = bio.trim();
            
            // Create variants of the name to check
            const nameVariants = [
                name,
                name.replace(/\./g, ''),  // Remove periods (R.C. -> RC)
                name.replace(/\s+/g, ' ').trim()  // Normalize spaces
            ];
            
            for (const nameVariant of nameVariants) {
                // Check if bio starts with the name (with optional punctuation/whitespace after)
                const escapedName = nameVariant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const nameRegex = new RegExp(`^${escapedName}[,.:;]?\\s*`, 'i');
                
                if (nameRegex.test(cleanedBio)) {
                    cleanedBio = cleanedBio.replace(nameRegex, '').trim();
                    // Capitalize first letter after removing name
                    if (cleanedBio.length > 0) {
                        cleanedBio = cleanedBio.charAt(0).toUpperCase() + cleanedBio.slice(1);
                    }
                    break;
                }
            }
            
            return cleanedBio;
        }

        // Search Audible
        async function searchAudible(name) {
            // Try the narrator search page instead of /ep/narrator which seems deprecated
            const searchUrl = `https://www.audible.com/search?searchNarrator=${encodeURIComponent(name)}`;
            log(`Audible: Fetching ${searchUrl}`);
            
            try {
                const html = await fetchViaProxy(searchUrl);
                
                if (html.length < 5000) {
                    log('Audible: Page not found or empty', 'error');
                    return null;
                }

                const result = {
                    source: 'audible',
                    url: searchUrl,
                    name: null,
                    imageUrl: null,
                    tagline: null,
                    bio: null,
                    books: [],
                    awards: []
                };

                // The search results page shows books narrated by this person
                // Extract book titles from the results
                const bookMatches = html.matchAll(/title['"]\s*:\s*['"]((?:[^'"\\]|\\.)*)['"]|class="bc-heading[^"]*"[^>]*>([^<]+)</gi);
                for (const match of bookMatches) {
                    const title = stripHtml(match[1] || match[2] || '').trim();
                    if (title && title.length > 3 && title.length < 100 && 
                        !title.includes('Audible') && !title.includes('Sign') &&
                        !result.books.includes(title) && result.books.length < 15) {
                        result.books.push(title);
                    }
                }
                
                // Set the narrator name
                result.name = name;
                
                log(`Audible: Found ${result.books.length} books`);
                
                // Audible search pages don't have narrator images, so we won't get one here
                // But we still return the result for the books list
                
                if (result.books.length > 0) {
                    return result;
                }
                
                log('Audible: No results found', 'error');
                return null;

            } catch (error) {
                log(`Audible: Error - ${error.message}`, 'error');
                return null;
            }
        }

        // Search Wikipedia
        async function searchWikipedia(name) {
            // Capitalize each word for Wikipedia (Wikipedia URLs are case-sensitive)
            const capitalizedName = name.split(/\s+/)
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join('_');
            
            // Create a version with periods and spaces for initials (RC -> R. C.)
            const nameWithPeriods = name.split(/\s+/)
                .map(word => {
                    // If word is 2-3 uppercase letters (initials), add periods and spaces
                    if (word.length <= 3 && /^[A-Za-z]+$/.test(word) && word.toUpperCase() === word) {
                        // RC -> R. C.
                        return word.toUpperCase().split('').join('. ').trim() + '.';
                    }
                    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                })
                .join('_');
            
            // Try narrator/actor variants FIRST, then general name
            const variants = [
                capitalizedName + '_(voice_actor)',
                capitalizedName + '_(narrator)',
                capitalizedName + '_(actor)',
                nameWithPeriods + '_(voice_actor)',
                nameWithPeriods + '_(narrator)',
                nameWithPeriods + '_(actor)',
                capitalizedName,  // Try general name last
                nameWithPeriods
            ];
            
            // Remove duplicates
            const uniqueVariants = [...new Set(variants)];
            
            for (const variant of uniqueVariants) {
                const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(variant)}`;
                log(`Wikipedia: Fetching ${url}`);

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        continue; // Try next variant
                    }

                    const data = await response.json();

                    if (data.type === 'disambiguation' || data.type === 'not_found') {
                        continue; // Try next variant
                    }

                    // Check if this Wikipedia article is about a narrator/voice actor
                    const bio = (data.extract || '').toLowerCase();
                    const isNarrator = bio.includes('narrator') || 
                                       bio.includes('voice actor') || 
                                       bio.includes('voice-over') ||
                                       bio.includes('voiceover') ||
                                       bio.includes('audiobook') ||
                                       bio.includes('audio book') ||
                                       bio.includes('voice artist');
                    
                    const isActor = bio.includes('actor') || bio.includes('actress');
                    const isAuthor = bio.includes('author') || bio.includes('writer');
                    
                    // Accept if they're an actor, narrator, or author (many authors narrate their own books)
                    const isLikelyNarrator = isNarrator || isActor || isAuthor;
                    
                    // Only filter out people who are DEFINITELY not narrators
                    const isDefinitelyNotNarrator = !isLikelyNarrator && (
                        // Sports
                        bio.includes('football player') ||
                        bio.includes('basketball player') ||
                        bio.includes('baseball player') ||
                        bio.includes('soccer player') ||
                        bio.includes('hockey player') ||
                        bio.includes('professional athlete') ||
                        // Politics
                        bio.includes('politician') ||
                        bio.includes('senator') ||
                        bio.includes('congressman') ||
                        bio.includes('governor') ||
                        // Other clearly non-narrator professions
                        bio.includes('serial killer') ||
                        bio.includes('murderer')
                    );
                    
                    if (isDefinitelyNotNarrator) {
                        log(`Wikipedia: Found "${data.title}" but appears to be wrong person, trying next variant...`);
                        continue; // Try next variant
                    }

                    const result = {
                        source: 'wikipedia',
                        url: data.content_urls?.desktop?.page || url,
                        name: data.title,
                        bio: data.extract,
                        imageUrl: data.thumbnail?.source?.replace('/50px-', '/300px-') || 
                                  data.originalimage?.source
                    };

                    log(`Wikipedia: Found! "${data.title}" - Bio: ${result.bio?.length || 0} chars`);
                    return result;

                } catch (error) {
                    log(`Wikipedia: Error with variant ${variant} - ${error.message}`, 'error');
                    continue;
                }
            }
            
            log('Wikipedia: Not found (tried all variants)', 'error');
            return null;
        }

        // Search AudioFile Magazine
        async function searchAudioFile(name) {
            // Try the normal slug first, then expanded slug for initials
            const urls = [
                SOURCES.audiofile.getUrl(name),
                `https://www.audiofilemagazine.com/narrators/${nameToSlugExpanded(name)}/`
            ];
            
            // Remove duplicates
            const uniqueUrls = [...new Set(urls)];
            
            for (const url of uniqueUrls) {
                log(`AudioFile: Fetching ${url}`);

                try {
                    const html = await fetchViaProxy(url);

                    // Better detection - check for actual narrator content
                    const hasNarratorContent = html.includes('Spotlight on') || 
                                               html.includes('Recent audiobooks') ||
                                               html.includes('Talking with') ||
                                               html.includes('/narrators/');
                    
                    if (!hasNarratorContent || html.length < 2000) {
                        log(`AudioFile: No narrator content at ${url}`, 'error');
                        continue; // Try next URL
                    }

                    const result = {
                        source: 'audiofile',
                        url: url,
                        imageUrl: null,
                        bio: null,
                        accents: [],
                        genres: [],
                        awards: []
                    };

                    // Extract narrator image
                    // Pattern: /images/400x400/content/uploaded/images/narrators/name.jpg
                    // or /content/uploaded/images/narrators/name.jpg
                    const imgPatterns = [
                        /src="(https?:\/\/[^"]*\/images\/\d+x\d+\/content\/uploaded\/images\/narrators\/[^"]+\.(?:jpg|jpeg|png))"/i,
                        /src="([^"]*\/content\/uploaded\/images\/narrators\/[^"]+\.(?:jpg|jpeg|png))"/i,
                        /src="([^"]*narrators\/[^"]+\.(?:jpg|jpeg|png))"/i
                    ];
                    
                    for (const pattern of imgPatterns) {
                        const match = html.match(pattern);
                        if (match) {
                            let imgUrl = match[1];
                            // Make sure it's a full URL
                            if (!imgUrl.startsWith('http')) {
                                imgUrl = 'https://www.audiofilemagazine.com' + (imgUrl.startsWith('/') ? '' : '/') + imgUrl;
                            }
                            // Skip small icons (200x200 are usually icons, not main photos)
                            if (!imgUrl.includes('200x200') && !imgUrl.includes('icon')) {
                                result.imageUrl = imgUrl;
                                log(`AudioFile: Found image`);
                                break;
                            }
                        }
                    }

                    // Extract accents
                    const accentsMatch = html.match(/Accents?:\s*([^¬∑<\n]+)/i);
                    if (accentsMatch) {
                        result.accents = accentsMatch[1].split(',').map(a => a.trim()).filter(a => a);
                        log(`AudioFile: Found ${result.accents.length} accents`);
                    }

                    // Extract genres
                    const genresMatch = html.match(/Genres?:\s*([^¬∑<\n]+)/i);
                    if (genresMatch) {
                        result.genres = genresMatch[1].split(',').map(g => g.trim()).filter(g => g);
                        log(`AudioFile: Found ${result.genres.length} genres`);
                    }

                    // Extract awards from accolades section
                    const awardsMatches = html.matchAll(/(Audies? Award[^<*]*|AudioFile Best of \d+[^<*]*|Earphones Award[^<*]*)/gi);
                    for (const match of awardsMatches) {
                        const award = match[1].trim();
                        if (award && !result.awards.includes(award) && result.awards.length < 10) {
                            result.awards.push(award);
                        }
                    }

                    if (html.includes('Golden Voice') && !result.awards.some(a => a.includes('Golden'))) {
                        result.awards.push('AudioFile Golden Voice');
                    }
                    log(`AudioFile: Found ${result.awards.length} awards`);

                    // Extract bio from "Talking with" section
                    const talkingWithMatch = html.match(/Talking with[^<]*<\/h3>([\s\S]*?)(?:<h3|Read More|Photo courtesy)/i);
                    if (talkingWithMatch) {
                        // Get paragraphs from the section
                        const section = talkingWithMatch[1];
                        const paragraphs = section.match(/<p[^>]*>([\s\S]*?)<\/p>/gi);
                        if (paragraphs && paragraphs.length > 0) {
                            // Get first 2-3 paragraphs
                            const bioText = paragraphs.slice(0, 3)
                                .map(p => stripHtml(p))
                                .filter(p => p.length > 50)
                                .join(' ');
                            if (bioText.length > 100) {
                                result.bio = bioText;
                                log(`AudioFile: Found bio (${result.bio.length} chars)`);
                            }
                        }
                    }

                    return result;

                } catch (error) {
                    log(`AudioFile: Error trying ${url} - ${error.message}`, 'error');
                    continue; // Try next URL
                }
            }
            
            log('AudioFile: Page not found', 'error');
            return null;
        }

        // Search Soundbooth Theater
        async function searchSoundbooth(name) {
            const url = SOURCES.soundbooth.getUrl(name);
            log(`Soundbooth: Fetching ${url}`);

            try {
                const html = await fetchViaProxy(url);

                // Check if page exists
                if (html.includes('Page not found') || html.includes('404') || html.length < 2000) {
                    log('Soundbooth: Page not found', 'error');
                    return null;
                }

                const result = {
                    source: 'soundbooth',
                    url: url,
                    name: null,
                    imageUrl: null,
                    bio: null,
                    books: []
                };

                // Extract name from h1
                const nameMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
                if (nameMatch) {
                    result.name = stripHtml(nameMatch[1]);
                    log(`Soundbooth: Found name "${result.name}"`);
                }

                // Extract profile image - they use wp-content/uploads
                const imgMatch = html.match(/src="(https:\/\/soundbooththeater\.com\/wp-content\/uploads\/[^"]+(?:jpg|jpeg|png)[^"]*)"/i);
                if (imgMatch) {
                    result.imageUrl = imgMatch[1];
                    log(`Soundbooth: Found image`);
                }

                // Alternative image pattern - look for team member images
                if (!result.imageUrl) {
                    const altImgMatch = html.match(/uploads\/\d+\/\d+\/[^"]*(?:jpg|jpeg|png)/i);
                    if (altImgMatch) {
                        result.imageUrl = `https://soundbooththeater.com/wp-content/${altImgMatch[0]}`;
                        log(`Soundbooth: Found image (alt pattern)`);
                    }
                }

                // Extract bio - usually in paragraphs after the title
                const bioMatch = html.match(/<h3[^>]*>Narrator<\/h3>[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i);
                if (bioMatch) {
                    result.bio = stripHtml(bioMatch[1]);
                    log(`Soundbooth: Found bio (${result.bio.length} chars)`);
                }

                // Alternative bio extraction
                if (!result.bio) {
                    const altBioMatch = html.match(/is an? (?:actor|narrator|voice)[^<]{50,800}/i);
                    if (altBioMatch) {
                        result.bio = stripHtml(altBioMatch[0]);
                        log(`Soundbooth: Found bio (alt pattern, ${result.bio.length} chars)`);
                    }
                }

                // Extract audiobook titles
                const bookMatches = html.matchAll(/<h6[^>]*>([^<]+)<\/h6>/gi);
                for (const match of bookMatches) {
                    const title = stripHtml(match[1]);
                    if (title.length > 3 && !result.books.includes(title) && result.books.length < 10) {
                        result.books.push(title);
                    }
                }
                log(`Soundbooth: Found ${result.books.length} books`);

                return result;

            } catch (error) {
                log(`Soundbooth: Error - ${error.message}`, 'error');
                return null;
            }
        }

        // Search Voices to Know
        async function searchVoicesToKnow(name) {
            const url = SOURCES.voicestoknow.getUrl(name);
            log(`Voices to Know: Fetching ${url}`);

            try {
                const html = await fetchViaProxy(url);

                // Check if page exists - look for narrator name in h1 or title
                // Don't just check for generic "not found" since the page might have that text elsewhere
                const hasNarratorContent = html.includes('<h1') && 
                                           (html.includes('Photo courtesy') || 
                                            html.includes('Recent Audiobooks') ||
                                            html.includes('Full Audiography'));
                
                if (!hasNarratorContent || html.length < 5000) {
                    log('Voices to Know: Page not found', 'error');
                    return null;
                }

                const result = {
                    source: 'voicestoknow',
                    url: url,
                    name: null,
                    imageUrl: null,
                    tagline: null,
                    bio: null,
                    books: [],
                    awards: []
                };

                // Extract name from h1
                const nameMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
                if (nameMatch) {
                    result.name = stripHtml(nameMatch[1]);
                    log(`Voices to Know: Found name "${result.name}"`);
                }

                // Extract profile image - look for wp-content/uploads images
                // Pattern: https://voicestoknow.com/wp-content/uploads/...jpg
                const imgPatterns = [
                    /src="(https:\/\/voicestoknow\.com\/wp-content\/uploads\/[^"]+\.(?:jpg|jpeg|png))"/i,
                    /!\[([^\]]*)\]\((https:\/\/voicestoknow\.com\/wp-content\/uploads\/[^)]+\.(?:jpg|jpeg|png))\)/i,
                    /"(https:\/\/voicestoknow\.com\/wp-content\/uploads\/\d+\/\d+\/[^"]+\.(?:jpg|jpeg|png))"/i
                ];
                
                for (const pattern of imgPatterns) {
                    const match = html.match(pattern);
                    if (match) {
                        // Get the URL (might be in different capture groups)
                        const imgUrl = match[2] || match[1];
                        // Skip logos, icons, and cover images
                        if (!imgUrl.includes('Logo') && 
                            !imgUrl.includes('logo') && 
                            !imgUrl.includes('icon') &&
                            !imgUrl.includes('/covers/')) {
                            result.imageUrl = imgUrl;
                            log(`Voices to Know: Found image`);
                            break;
                        }
                    }
                }

                // Extract tagline (the quote under the name - usually in italics or a specific class)
                // Look for actual quote content, not HTML attributes
                const taglinePatterns = [
                    /<em[^>]*>"([^"<]{10,150})"<\/em>/i,
                    /<blockquote[^>]*>([^<]{10,150})<\/blockquote>/i,
                    /<p[^>]*class="[^"]*quote[^"]*"[^>]*>([^<]{10,150})<\/p>/i,
                    />[""]([^""<]{10,150})[""]</i
                ];
                
                for (const pattern of taglinePatterns) {
                    const match = html.match(pattern);
                    if (match && !match[1].includes('Voices To Know') && !match[1].includes('itemtype')) {
                        result.tagline = stripHtml(match[1]).trim();
                        log(`Voices to Know: Found tagline`);
                        break;
                    }
                }

                // Extract bio from "Talking with" or "About" section
                const bioMatch = html.match(/Talking with[^<]*<\/h3>[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i) ||
                                 html.match(/About[^<]*<\/h2>[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i);
                if (bioMatch) {
                    result.bio = stripHtml(bioMatch[1]);
                    log(`Voices to Know: Found bio (${result.bio.length} chars)`);
                }

                // Extract awards/accolades
                const accoladesSection = html.match(/Accolades[\s\S]*?(?=##|<\/section)/i);
                if (accoladesSection) {
                    // Look for award mentions
                    const awardMatches = accoladesSection[0].matchAll(/(AudioFile Best of \d+[^<]*|Audie Award[^<]*)/gi);
                    for (const match of awardMatches) {
                        const award = stripHtml(match[1]);
                        if (!result.awards.includes(award) && result.awards.length < 10) {
                            result.awards.push(award);
                        }
                    }
                    log(`Voices to Know: Found ${result.awards.length} awards`);
                }

                // Extract recent audiobooks
                const booksSection = html.match(/Recent Audiobooks[\s\S]*?(?=##|Want to see more)/i);
                if (booksSection) {
                    const bookMatches = booksSection[0].matchAll(/title="([^"]+)"/gi);
                    for (const match of bookMatches) {
                        const title = stripHtml(match[1]);
                        if (title.length > 3 && !result.books.includes(title) && result.books.length < 10) {
                            result.books.push(title);
                        }
                    }
                    log(`Voices to Know: Found ${result.books.length} books`);
                }

                return result;

            } catch (error) {
                log(`Voices to Know: Error - ${error.message}`, 'error');
                return null;
            }
        }

        // Search Tantor
        async function searchTantor(name) {
            const url = SOURCES.tantor.getUrl(name);
            log(`Tantor: Fetching ${url}`);

            try {
                const html = await fetchViaProxy(url);

                if (html.includes('Page Not Found') || html.includes('404') || html.length < 1000) {
                    log('Tantor: Page not found', 'error');
                    return null;
                }

                const result = {
                    source: 'tantor',
                    url: url,
                    name: null,
                    imageUrl: null,
                    bio: null,
                    books: []
                };

                // Extract narrator name from page title or h1
                const nameMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i) ||
                                  html.match(/<title>\s*Tantor Media\s*-\s*([^<|]+)/i);
                if (nameMatch) {
                    result.name = stripHtml(nameMatch[1]).trim();
                    log(`Tantor: Found name "${result.name}"`);
                }

                // IMPORTANT: Verify this is the right person
                // Check if the found name matches what we searched for
                if (result.name) {
                    const searchNameLower = name.toLowerCase().replace(/[^a-z]/g, '');
                    const foundNameLower = result.name.toLowerCase().replace(/[^a-z]/g, '');
                    
                    // Check for reasonable name match
                    const searchParts = name.toLowerCase().split(/\s+/);
                    const foundParts = result.name.toLowerCase().split(/\s+/);
                    
                    const lastNameSearch = searchParts[searchParts.length - 1];
                    const lastNameFound = foundParts[foundParts.length - 1];
                    
                    if (!lastNameFound || !lastNameSearch || 
                        (!lastNameFound.includes(lastNameSearch) && !lastNameSearch.includes(lastNameFound))) {
                        log(`Tantor: Name mismatch - searched "${name}" but found "${result.name}", skipping`, 'error');
                        return null;
                    }
                } else {
                    // No name found - this is probably not the right page
                    log('Tantor: Could not verify narrator name, skipping', 'error');
                    return null;
                }

                // Extract profile image
                const imgPatterns = [
                    /src="(https:\/\/tantor[^"]+\.(?:jpg|jpeg|png))"/i,
                    /src="([^"]*narrator[^"]*\.(?:jpg|jpeg|png))"/i,
                    /src="(https?:\/\/[^"]+\/images\/narrators\/[^"]+\.(?:jpg|jpeg|png))"/i
                ];
                
                for (const pattern of imgPatterns) {
                    const match = html.match(pattern);
                    if (match && !match[1].includes('logo') && !match[1].includes('icon')) {
                        result.imageUrl = match[1];
                        if (!result.imageUrl.startsWith('http')) {
                            result.imageUrl = 'https://tantor.com' + result.imageUrl;
                        }
                        log(`Tantor: Found image`);
                        break;
                    }
                }

                // Extract bio - look for paragraph with narrator keywords
                // First, try to find the bio in common container patterns
                let bioFound = false;
                
                // Pattern 1: Look for dedicated bio/about sections
                const sectionPatterns = [
                    /<div[^>]*class="[^"]*(?:narrator-bio|narrator-about|bio-text|about-text|description)[^"]*"[^>]*>([\s\S]*?)<\/div>/i,
                    /<section[^>]*class="[^"]*(?:bio|about)[^"]*"[^>]*>([\s\S]*?)<\/section>/i,
                ];
                
                for (const pattern of sectionPatterns) {
                    const match = html.match(pattern);
                    if (match) {
                        const text = stripHtml(match[1]).trim();
                        if (text.length > 80 && !text.includes('¬ª')) {
                            result.bio = cleanBio(text, result.name || name);
                            log(`Tantor: Found bio in section (${result.bio.length} chars)`);
                            bioFound = true;
                            break;
                        }
                    }
                }
                
                // Pattern 2: Find all paragraphs and look for the best bio candidate
                if (!bioFound) {
                    const paragraphRegex = /<p[^>]*>([\s\S]*?)<\/p>/gi;
                    let bestBio = null;
                    let bestScore = 0;
                    
                    let match;
                    while ((match = paragraphRegex.exec(html)) !== null) {
                        const text = stripHtml(match[1]).trim();
                        
                        // Skip if too short or contains navigation indicators
                        if (text.length < 80) continue;
                        if (text.includes('¬ª') || text.includes('BESTSELLER') || 
                            text.includes('BARGAIN') || text.includes('Add to Cart') ||
                            text.includes('Sign In') || text.includes('Shopping Cart')) continue;
                        
                        // Score the paragraph
                        let score = 0;
                        
                        // Positive indicators (bio-like content)
                        if (/\b(narrator|narrates|narrated|narrating)\b/i.test(text)) score += 30;
                        if (/\b(audiobook|audio book)\b/i.test(text)) score += 25;
                        if (/\b(voice actor|voice-over|voiceover)\b/i.test(text)) score += 25;
                        if (/\b(Audie|Earphones|AudioFile)\b/i.test(text)) score += 20;
                        if (/\b(award|awards|winner|winning)\b/i.test(text)) score += 15;
                        if (/\b(actor|actress|acting|stage|theater|theatre|Broadway)\b/i.test(text)) score += 15;
                        if (/\b(graduate|graduated|BA|MFA|college|university|degree)\b/i.test(text)) score += 15;
                        if (/\b(born|raised|grew up)\b/i.test(text)) score += 10;
                        if (/\b(she |he |her |his |they )\b/i.test(text)) score += 10;
                        
                        // Length bonus (longer is usually better for bios)
                        if (text.length > 200) score += 20;
                        if (text.length > 400) score += 20;
                        
                        // Check if this is the best candidate
                        if (score > bestScore && score >= 20) {
                            bestScore = score;
                            bestBio = text;
                        }
                    }
                    
                    if (bestBio) {
                        result.bio = cleanBio(bestBio, result.name || name);
                        log(`Tantor: Found bio (${result.bio.length} chars, score: ${bestScore})`);
                    }
                }

                // Extract book titles
                const bookMatches = html.matchAll(/title['"]\s*:\s*['"]([^'"]+)['"]/gi);
                for (const match of bookMatches) {
                    const title = stripHtml(match[1]).trim();
                    if (title.length > 3 && !result.books.includes(title) && result.books.length < 10) {
                        result.books.push(title);
                    }
                }
                if (result.books.length > 0) {
                    log(`Tantor: Found ${result.books.length} books`);
                }

                return result;

            } catch (error) {
                log(`Tantor: Error - ${error.message}`, 'error');
                return null;
            }
        }

        // Search SoundCloud
        async function searchSoundCloud(name) {
            // Try multiple username formats
            const nameLower = name.toLowerCase();
            const nameParts = nameLower.split(/\s+/);
            const firstName = nameParts[0] || '';
            const lastName = nameParts[nameParts.length - 1] || '';
            const middleName = nameParts.length > 2 ? nameParts.slice(1, -1).join('') : '';
            
            const usernameVariants = [
                // First-Last (most common for personal accounts)
                `${firstName}-${lastName}`,
                `${firstName}${lastName}`,
                `${firstName}_${lastName}`,
                // Full name variations
                nameLower.replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, ''),
                nameLower.replace(/\s+/g, '').replace(/[^a-z0-9]/g, ''),
                nameLower.replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, ''),
                // Last name only
                lastName,
                // First + middle + last (no separators)
                `${firstName}${middleName}${lastName}`,
            ].filter(v => v && v.length > 2);
            
            // Remove duplicates
            const uniqueVariants = [...new Set(usernameVariants)];
            
            for (const username of uniqueVariants) {
                const url = `https://soundcloud.com/${username}`;
                log(`SoundCloud: Trying ${url}`);

                try {
                    const html = await fetchViaProxy(url);
                    
                    log(`SoundCloud: Response length: ${html.length}`);

                    // Check if profile exists - SoundCloud error pages are typically shorter
                    // and contain specific error messages
                    const isErrorPage = html.includes("We can't find that user") || 
                        html.includes('Something went wrong') ||
                        html.includes('This user has been suspended') ||
                        html.includes('Page not found') ||
                        html.length < 1000;
                    
                    if (isErrorPage) {
                        log(`SoundCloud: Profile not found at ${username}`);
                        continue; // Try next variant
                    }
                    
                    // Check if this looks like a valid SoundCloud page with actual content
                    const hasSoundCloudContent = html.includes('sndcdn.com') || 
                                                  html.includes('soundcloud.com') ||
                                                  html.includes('sc-classic');
                    
                    // Look for avatar image first - this is the best indicator of a real profile
                    const hasAvatar = html.includes('avatars-') || html.includes('avatar_url');
                    
                    if (!hasSoundCloudContent && !hasAvatar) {
                        log(`SoundCloud: No SoundCloud content at ${username}`);
                        continue;
                    }
                    
                    log(`SoundCloud: Valid page found for ${username}`);

                    const result = {
                        source: 'soundcloud',
                        url: url,
                        name: null,
                        imageUrl: null,
                        bio: null
                    };

                    // Extract profile name from title or h1
                    const nameMatch = html.match(/<title>([^|<-]+)/i) ||
                                      html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
                    if (nameMatch) {
                        result.name = stripHtml(nameMatch[1]).trim();
                        log(`SoundCloud: Found name "${result.name}"`);
                    }

                    // Extract avatar image - SoundCloud uses sndcdn.com for images
                    // Try multiple patterns
                    const imgPatterns = [
                        /avatars-[^"'\s]+\.jpg/gi,
                        /(https:\/\/i1\.sndcdn\.com\/avatars-[^"'\s]+)/gi,
                        /"avatar_url"\s*:\s*"([^"]+)"/i,
                        /avatars[^"']*-t(?:1080x1080|500x500|200x200|large|original)[^"']*\.jpg/gi
                    ];
                    
                    for (const pattern of imgPatterns) {
                        const imgMatch = html.match(pattern);
                        if (imgMatch) {
                            let imgUrl = imgMatch[1] || imgMatch[0];
                            if (!imgUrl.startsWith('http')) {
                                imgUrl = 'https://i1.sndcdn.com/' + imgUrl;
                            }
                            // Upgrade to larger size
                            imgUrl = imgUrl.replace(/-t\d+x\d+/, '-t500x500')
                                          .replace(/-large/, '-t500x500')
                                          .replace(/-original/, '-t500x500');
                            result.imageUrl = imgUrl;
                            log(`SoundCloud: Found image: ${imgUrl.substring(0, 60)}...`);
                            break;
                        }
                    }

                    // Extract bio/description
                    const bioMatch = html.match(/(?:description|bio)[^>]*>([^<]{20,500})/i);
                    if (bioMatch) {
                        result.bio = stripHtml(bioMatch[1]);
                        log(`SoundCloud: Found bio (${result.bio.length} chars)`);
                    }

                    if (result.imageUrl || result.bio) {
                        return result;
                    }

                } catch (error) {
                    continue; // Try next variant
                }
            }
            
            log('SoundCloud: Profile not found', 'error');
            return null;
        }

        // Search for personal website
        async function searchPersonalSite(name) {
            const nameLower = name.toLowerCase();
            const nameParts = nameLower.split(/\s+/);
            const firstName = nameParts[0] || '';
            const lastName = nameParts[nameParts.length - 1] || '';
            const fullNameNoSpaces = nameLower.replace(/\s+/g, '');
            
            // Common personal website domain patterns
            const domainVariants = [
                `${fullNameNoSpaces}.com`,              // jamesdanielburkdoll.com
                `www.${fullNameNoSpaces}.com`,          // www.jamesdanielburkdoll.com
                `${firstName}${lastName}.com`,          // jamesburkdoll.com
                `www.${firstName}${lastName}.com`,
                `${firstName}-${lastName}.com`,
                `www.${firstName}-${lastName}.com`,
            ];
            
            const uniqueDomains = [...new Set(domainVariants)];
            
            for (const domain of uniqueDomains) {
                const url = `https://${domain}`;
                log(`Personal Site: Trying ${url}`);
                
                try {
                    const html = await fetchViaProxy(url);
                    log(`Personal Site: Response length: ${html.length}`);
                    
                    // Check if it's a real page (not a parked domain or error)
                    if (html.length < 2000 || 
                        html.includes('domain is for sale') ||
                        html.includes('buy this domain') ||
                        html.includes('parked') ||
                        html.includes('Page Not Found') ||
                        html.includes('404 Not Found')) {
                        log(`Personal Site: Invalid page for ${domain}`);
                        continue;
                    }
                    
                    log(`Personal Site: Valid page found at ${domain}`);
                    
                    const result = {
                        source: 'personalsite',
                        url: url,
                        name: name,
                        imageUrl: null,
                        bio: null
                    };
                    
                    // Look for ANY jpg/png image that's likely a profile photo
                    const imgPatterns = [
                        // Images with profile-like keywords in src or alt
                        /<img[^>]+src=["']([^"']+\.(?:jpg|jpeg|png|webp)[^"']*)["'][^>]*(?:alt=["'][^"']*(?:james|burkdoll|headshot|profile|author|narrator)[^"']*["'])?/gi,
                        // Any reasonably-sized image
                        /<img[^>]+src=["']([^"']+\.(?:jpg|jpeg|png|webp))["']/gi,
                        // Background images
                        /background(?:-image)?:\s*url\(['"]?([^'")\s]+\.(?:jpg|jpeg|png|webp))['"]?\)/gi,
                        // Open Graph image
                        /<meta[^>]+property=["']og:image["'][^>]+content=["']([^"']+)["']/gi
                    ];
                    
                    for (const pattern of imgPatterns) {
                        const matches = html.matchAll(pattern);
                        for (const match of matches) {
                            let imgUrl = match[1];
                            if (!imgUrl) continue;
                            
                            // Skip icons, logos, tiny images
                            if (imgUrl.includes('icon') || 
                                imgUrl.includes('logo') || 
                                imgUrl.includes('button') ||
                                imgUrl.includes('favicon') ||
                                imgUrl.includes('sprite') ||
                                imgUrl.includes('1x1') ||
                                imgUrl.includes('pixel')) {
                                continue;
                            }
                            
                            if (!imgUrl.startsWith('http')) {
                                imgUrl = new URL(imgUrl, url).href;
                            }
                            result.imageUrl = imgUrl;
                            log(`Personal Site: Found image: ${imgUrl.substring(0, 60)}...`);
                            break;
                        }
                        if (result.imageUrl) break;
                    }
                    
                    // Look for bio/about text on homepage
                    let bioPatterns = [
                        /<(?:p|div)[^>]*(?:class|id)=["'][^"']*(?:bio|about|description)[^"']*["'][^>]*>([^<]{50,500})/gi,
                        /<meta[^>]+name=["']description["'][^>]+content=["']([^"]{50,300})["']/gi
                    ];
                    
                    for (const pattern of bioPatterns) {
                        const match = html.match(pattern);
                        if (match && match[1]) {
                            result.bio = stripHtml(match[1]).trim();
                            log(`Personal Site: Found bio on homepage (${result.bio.length} chars)`);
                            break;
                        }
                    }
                    
                    // Always try about page if we haven't found a good bio yet
                    if (!result.bio || result.bio.length < 100) {
                        const aboutPages = ['/about', '/bio', '/about-me', '/about/', '/bio/', '/about-me/'];
                        
                        for (const aboutPath of aboutPages) {
                            try {
                                const aboutUrl = `https://${domain}${aboutPath}`;
                                log(`Personal Site: Checking about page ${aboutUrl}`);
                                const aboutHtml = await fetchViaProxy(aboutUrl);
                                
                                if (aboutHtml.length < 1000 || 
                                    aboutHtml.includes('Page Not Found') ||
                                    aboutHtml.includes('404 Not Found')) {
                                    continue;
                                }
                                
                                log(`Personal Site: About page found, length: ${aboutHtml.length}`);
                                
                                // Extract paragraphs from about page - look for substantial text
                                const paragraphMatches = aboutHtml.matchAll(/<p[^>]*>([^<]{100,})<\/p>/gi);
                                const paragraphs = [];
                                for (const match of paragraphMatches) {
                                    const text = stripHtml(match[1]).trim();
                                    // Skip navigation, footer text, etc.
                                    if (text.length > 100 && 
                                        !text.includes('cookie') && 
                                        !text.includes('privacy') &&
                                        !text.includes('copyright') &&
                                        !text.includes('¬©')) {
                                        paragraphs.push(text);
                                    }
                                }
                                
                                if (paragraphs.length > 0) {
                                    // Take up to first 3 paragraphs, max 1000 chars
                                    result.bio = paragraphs.slice(0, 3).join(' ').substring(0, 1000);
                                    log(`Personal Site: Found bio on about page (${result.bio.length} chars)`);
                                    
                                    // Also check about page for a better image if we don't have one
                                    if (!result.imageUrl) {
                                        for (const pattern of imgPatterns) {
                                            const matches = aboutHtml.matchAll(pattern);
                                            for (const match of matches) {
                                                let imgUrl = match[1];
                                                if (!imgUrl) continue;
                                                if (imgUrl.includes('icon') || imgUrl.includes('logo') || 
                                                    imgUrl.includes('button') || imgUrl.includes('favicon')) {
                                                    continue;
                                                }
                                                if (!imgUrl.startsWith('http')) {
                                                    imgUrl = new URL(imgUrl, aboutUrl).href;
                                                }
                                                result.imageUrl = imgUrl;
                                                log(`Personal Site: Found image on about page`);
                                                break;
                                            }
                                            if (result.imageUrl) break;
                                        }
                                    }
                                    break;
                                }
                            } catch (e) {
                                // About page doesn't exist, try next
                                continue;
                            }
                        }
                    }
                    
                    if (result.imageUrl || result.bio) {
                        return result;
                    }
                    
                } catch (error) {
                    log(`Personal Site: Error for ${domain}: ${error.message}`);
                    continue; // Try next domain
                }
            }
            
            log('Personal Site: No site found', 'error');
            return null;
        }

        // Search IMDB for image (many narrators are also actors)
        async function searchIMDB(name) {
            log(`IMDB: Searching for ${name}`);

            try {
                // Strategy 1: Try the IMDB find page
                const searchUrl = `https://www.imdb.com/find/?q=${encodeURIComponent(name)}&s=nm`;
                const html = await fetchViaProxy(searchUrl);
                
                log(`IMDB: Search page fetched, length: ${html.length}`);

                // Try multiple patterns to find the profile URL
                let profilePath = null;
                
                // Pattern 1: Standard href to /name/nmXXXXXX
                const patterns = [
                    /href="(\/name\/nm\d+)\/?"/i,
                    /href='(\/name\/nm\d+)\/?'/i,
                    /\/name\/(nm\d+)/i,
                    /"(nm\d+)"/
                ];
                
                for (const pattern of patterns) {
                    const match = html.match(pattern);
                    if (match) {
                        profilePath = match[1].startsWith('/') ? match[1] : `/name/${match[1]}`;
                        log(`IMDB: Found profile path with pattern: ${profilePath}`);
                        break;
                    }
                }
                
                if (!profilePath) {
                    log('IMDB: No profile found in search results', 'error');
                    return null;
                }

                const profileUrl = `https://www.imdb.com${profilePath}/`;
                log(`IMDB: Fetching profile: ${profileUrl}`);

                // Fetch the actual profile page to get the real headshot
                const profileHtml = await fetchViaProxy(profileUrl);
                log(`IMDB: Profile page fetched, length: ${profileHtml.length}`);

                const result = {
                    source: 'imdb',
                    url: profileUrl,
                    imageUrl: null,
                    name: null
                };

                // Extract name from profile
                const titleMatch = profileHtml.match(/<title>([^|<]+)/i);
                if (titleMatch) {
                    result.name = titleMatch[1].replace(' - IMDb', '').trim();
                    log(`IMDB: Found name: ${result.name}`);
                }

                // IMPORTANT: Verify this is the right person!
                // Compare the found name with what we searched for
                const searchNameLower = name.toLowerCase().replace(/[^a-z]/g, '');
                const foundNameLower = (result.name || '').toLowerCase().replace(/[^a-z]/g, '');
                
                // Check if names are similar enough
                const searchParts = name.toLowerCase().split(/\s+/).filter(p => p.length > 0);
                const foundParts = (result.name || '').toLowerCase().split(/[\s.]+/).filter(p => p.length > 0);
                
                // At least the last name should match, or significant overlap
                const lastNameSearch = searchParts[searchParts.length - 1];
                const lastNameFound = foundParts[foundParts.length - 1];
                
                const firstNameSearch = searchParts[0];
                const firstNameFound = foundParts[0];
                
                const lastNameMatches = lastNameFound && lastNameSearch && 
                    (lastNameFound === lastNameSearch || 
                     lastNameFound.includes(lastNameSearch) || 
                     lastNameSearch.includes(lastNameFound));
                const firstNameMatches = firstNameFound && firstNameSearch &&
                    (firstNameFound === firstNameSearch ||
                     firstNameFound.includes(firstNameSearch) || 
                     firstNameSearch.includes(firstNameFound) ||
                     firstNameFound[0] === firstNameSearch[0]); // Initial match (R.C. vs RC)
                
                // If found name has more parts than search (like middle names), 
                // be stricter - require exact first AND last name match
                if (foundParts.length > searchParts.length) {
                    const exactFirstMatch = firstNameFound === firstNameSearch || 
                                           (firstNameSearch.length <= 3 && firstNameFound.startsWith(firstNameSearch));
                    const exactLastMatch = lastNameFound === lastNameSearch;
                    
                    if (!exactFirstMatch || !exactLastMatch) {
                        log(`IMDB: Name has extra parts - searched "${name}" but found "${result.name}" - might be different person, skipping`, 'error');
                        return null;
                    }
                }
                
                if (!lastNameMatches) {
                    log(`IMDB: Name mismatch! Searched "${name}" but found "${result.name}" - skipping`, 'error');
                    return null;
                }
                
                if (!firstNameMatches && !lastNameMatches) {
                    log(`IMDB: Name mismatch! Searched "${name}" but found "${result.name}" - skipping`, 'error');
                    return null;
                }
                
                log(`IMDB: Name verified - "${result.name}" matches search "${name}"`);
                
                // Additional check: Look for narrator/audiobook keywords on the profile page
                // If the person's bio doesn't mention narrator/audiobook/voice, they might be the wrong person
                const bioLower = html.toLowerCase();
                const isNarratorOnIMDB = bioLower.includes('narrator') || 
                                          bioLower.includes('audiobook') ||
                                          bioLower.includes('voice actor') ||
                                          bioLower.includes('voice-over') ||
                                          bioLower.includes('voiceover');
                
                // If this person has a middle name/initial that we didn't search for,
                // AND they're not clearly identified as a narrator on IMDB, skip them
                if (foundParts.length > searchParts.length && !isNarratorOnIMDB) {
                    log(`IMDB: "${result.name}" doesn't appear to be an audiobook narrator, skipping`, 'error');
                    return null;
                }

                // IMDB headshots are specifically in the profile header area
                // They have specific patterns like:
                // - Appear near "View Poster" or in the header section
                // - Usually have portrait crop ratios like CR13,0,140,207 or UY207
                // - Movie posters have different crops like CR22,0,90,133
                
                // First, look for images that appear to be headshots (portrait crops)
                // Portrait aspect ratio for headshots is usually ~140x207 or similar
                const headshotPatterns = [
                    // Look for the main profile image (usually first in header)
                    /class="[^"]*ipc-image[^"]*"[^>]*src="(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+)"/i,
                    // Images with portrait crop ratios (width < height significantly)
                    /(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+_CR\d+,0,140,207_[^"]+\.jpg)/gi,
                    /(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+_UY207_[^"]+\.jpg)/gi,
                    // Publicity images
                    /(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+Publicity[^"]+\.jpg)/gi,
                ];
                
                let headshotUrl = null;
                
                for (const pattern of headshotPatterns) {
                    const match = profileHtml.match(pattern);
                    if (match) {
                        headshotUrl = match[1];
                        log(`IMDB: Found potential headshot with pattern`);
                        break;
                    }
                }
                
                // Check if we found an actual headshot (not a movie poster)
                // Movie posters typically have CR22,0,90,133 (landscape-ish crop)
                if (headshotUrl) {
                    // Check if this looks like a movie poster (90x133 is typical movie poster crop)
                    if (headshotUrl.includes('CR22,0,90,133') || headshotUrl.includes('_UX90_')) {
                        log(`IMDB: Found image appears to be a movie poster, not a headshot`);
                        headshotUrl = null;
                    }
                }
                
                // If we still have a headshot, use it
                if (headshotUrl) {
                    // Upgrade to larger size
                    result.imageUrl = headshotUrl.replace(/\._V1_[^.]+\.jpg/, '._V1_UX400.jpg');
                    log(`IMDB: Selected headshot: ${result.imageUrl.substring(0, 70)}...`);
                    return result;
                }
                
                // Fallback: Check if there's a "Photos" section link which means they have photos
                const hasPhotos = profileHtml.includes('/mediaindex') || profileHtml.includes('Photos<');
                if (!hasPhotos) {
                    log('IMDB: No photos section found - person likely has no headshot');
                    return null;
                }
                
                // Try the media index page for this person
                const mediaUrl = `https://www.imdb.com${profilePath}/mediaindex/`;
                log(`IMDB: Checking media page: ${mediaUrl}`);
                
                try {
                    const mediaHtml = await fetchViaProxy(mediaUrl);
                    // Look for publicity/portrait photos
                    const mediaMatch = mediaHtml.match(/(https:\/\/m\.media-amazon\.com\/images\/M\/[^"]+\.jpg)/i);
                    if (mediaMatch) {
                        result.imageUrl = mediaMatch[1].replace(/\._V1_[^.]+\.jpg/, '._V1_UX400.jpg');
                        log(`IMDB: Found image from media page`);
                        return result;
                    }
                } catch (e) {
                    log(`IMDB: Media page fetch failed: ${e.message}`);
                }

                log('IMDB: No suitable headshot found', 'error');
                return null;

            } catch (error) {
                log(`IMDB: Error - ${error.message}`, 'error');
                return null;
            }
        }

        // Google search for narrator info and images
        async function searchGoogle(name) {
            // Use Google's search with specific terms for audiobook narrators
            const searchQueries = [
                `${name} narrator audiobook`,
                `${name} voice actor`,
                `"${name}" narrator`
            ];
            
            log(`Google: Searching for "${name}"`);

            try {
                const result = {
                    source: 'google',
                    url: `https://www.google.com/search?q=${encodeURIComponent(searchQueries[0])}`,
                    imageUrl: null
                };
                
                // Try each search query
                for (const searchQuery of searchQueries) {
                    // Try Google Images
                    const imageSearchUrl = `https://www.google.com/search?q=${encodeURIComponent(searchQuery)}&tbm=isch`;
                    
                    try {
                        const html = await fetchViaProxy(imageSearchUrl);
                        
                        // Google Images embeds image URLs in various formats
                        const patterns = [
                            /\["(https:\/\/[^"]+\.(?:jpg|jpeg|png))"[^\]]*,\s*\d+,\s*\d+\]/gi,
                            /"ou":"(https:\/\/[^"]+\.(?:jpg|jpeg|png)[^"]*)"/gi,
                            /\["(https:\/\/[^"]+\.(?:jpg|jpeg|png))",\d+,\d+\]/gi,
                            /data-src="(https:\/\/[^"]+\.(?:jpg|jpeg|png)[^"]*)"/gi,
                            /src="(https:\/\/encrypted-tbn[^"]+)"/gi,
                            /"(https:\/\/i1\.sndcdn\.com\/[^"]+)"/gi,  // SoundCloud images
                            /"(https:\/\/[^"]*avatars[^"]*\.(?:jpg|jpeg|png)[^"]*)"/gi
                        ];
                        
                        for (const pattern of patterns) {
                            const matches = html.matchAll(pattern);
                            for (const match of matches) {
                                const imgUrl = match[1];
                                // Skip Google's own assets and tiny images
                                if (!imgUrl.includes('google.com') && 
                                    !imgUrl.includes('gstatic.com') &&
                                    !imgUrl.includes('googleapis.com') &&
                                    !imgUrl.includes('icon') &&
                                    !imgUrl.includes('logo') &&
                                    !imgUrl.includes('button') &&
                                    !imgUrl.includes('1x1') &&
                                    !imgUrl.includes('placeholder') &&
                                    imgUrl.length > 50) {
                                    result.imageUrl = imgUrl;
                                    log(`Google: Found image from "${searchQuery}"`);
                                    return result;
                                }
                            }
                        }
                    } catch (e) {
                        log(`Google: Image search failed for "${searchQuery}": ${e.message}`);
                    }
                }
                
                // Try DuckDuckGo as fallback
                try {
                    const ddgUrl = `https://duckduckgo.com/?q=${encodeURIComponent(name + ' narrator')}&iax=images&ia=images`;
                    const ddgHtml = await fetchViaProxy(ddgUrl);
                    
                    // DuckDuckGo image patterns
                    const ddgPatterns = [
                        /"image":"(https:\/\/[^"]+\.(?:jpg|jpeg|png)[^"]*)"/gi,
                        /vqd=([^&]+)/
                    ];
                    
                    for (const pattern of ddgPatterns) {
                        const match = ddgHtml.match(pattern);
                        if (match && match[1] && match[1].startsWith('http')) {
                            result.imageUrl = match[1];
                            log(`Google: Found image via DuckDuckGo`);
                            return result;
                        }
                    }
                } catch (e) {
                    log(`DuckDuckGo fallback failed: ${e.message}`);
                }

                log('Google: No image found', 'error');
                return null;

            } catch (error) {
                log(`Google: Error - ${error.message}`, 'error');
                return null;
            }
        }

        // Search Wikimedia Commons for image
        async function searchWikimediaCommons(name) {
            const searchUrl = `https://commons.wikimedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(name)}&srnamespace=6&format=json&origin=*`;
            log(`Wikimedia Commons: Searching for ${name}`);

            try {
                const response = await fetch(searchUrl);
                if (!response.ok) {
                    log('Wikimedia Commons: Search failed', 'error');
                    return null;
                }

                const data = await response.json();
                const results = data.query?.search || [];

                // Look for a portrait/photo file
                for (const result of results) {
                    const title = result.title;
                    if (title.match(/\.(jpg|jpeg|png)$/i) && 
                        (title.toLowerCase().includes(name.toLowerCase().split(' ')[1]) || 
                         title.toLowerCase().includes('portrait') ||
                         title.toLowerCase().includes('photo'))) {
                        
                        // Get the actual file URL
                        const fileInfoUrl = `https://commons.wikimedia.org/w/api.php?action=query&titles=${encodeURIComponent(title)}&prop=imageinfo&iiprop=url&format=json&origin=*`;
                        const fileResponse = await fetch(fileInfoUrl);
                        const fileData = await fileResponse.json();
                        
                        const pages = fileData.query?.pages || {};
                        const page = Object.values(pages)[0];
                        const imageUrl = page?.imageinfo?.[0]?.url;
                        
                        if (imageUrl) {
                            log(`Wikimedia Commons: Found image`);
                            return {
                                source: 'wikimedia',
                                url: `https://commons.wikimedia.org/wiki/${encodeURIComponent(title)}`,
                                imageUrl: imageUrl
                            };
                        }
                    }
                }

                log('Wikimedia Commons: No suitable image found', 'error');
                return null;

            } catch (error) {
                log(`Wikimedia Commons: Error - ${error.message}`, 'error');
                return null;
            }
        }

        // Dedicated image search as fallback
        async function searchForImage(name, existingResults) {
            // Check if we already have an image
            for (const result of existingResults) {
                if (result?.imageUrl) {
                    return null; // Already have an image
                }
            }

            log('No image found in primary sources, trying fallback image searches...');

            // Try IMDB first (best for actors/narrators)
            const imdbResult = await searchIMDB(name);
            if (imdbResult?.imageUrl) {
                return imdbResult;
            }

            // Try Wikimedia Commons
            const commonsResult = await searchWikimediaCommons(name);
            if (commonsResult?.imageUrl) {
                return commonsResult;
            }

            return null;
        }

        // Image quality/priority scoring
        function scoreImage(imageUrl, source) {
            if (!imageUrl) return 0;
            
            // Blocklist of known wrong person images - reject these completely
            const blockedImages = [
                'MV5BZWZmNDU4NjAtZTQxNC00ODg3LWFhZjgtODNiODc1N2I1M2M3', // Wayne T. Carr (actor, not narrator)
            ];
            
            for (const blocked of blockedImages) {
                if (imageUrl.includes(blocked)) {
                    log(`Blocked known wrong-person image: ${blocked}`, 'error');
                    return -1000; // Return very negative score to filter out
                }
            }
            
            let score = 0;
            
            // Prioritize by source (headshot-focused sources score higher)
            const sourceScores = {
                'imdb': 100,
                'wikipedia': 90,
                'voicestoknow': 85,
                'audiofile': 85,
                'soundcloud': 80,
                'soundbooth': 75,
                'audible': 50,
                'tantor': 40,
                'google': 20
            };
            score += sourceScores[source] || 10;
            
            // CRITICAL: Distinguish IMDB headshots (/images/M/) from product images (/images/I/)
            if (imageUrl.includes('/images/M/')) {
                score += 50;
            }
            if (imageUrl.includes('/images/I/')) {
                score -= 80;
            }
            
            // Penalize likely book covers
            if (imageUrl.includes('_SL') || imageUrl.includes('_AC_')) {
                score -= 60;
            }
            if (imageUrl.includes('cover') || imageUrl.includes('book')) {
                score -= 40;
            }
            
            // Boost likely headshots/portraits
            if (imageUrl.includes('portrait') || imageUrl.includes('headshot')) {
                score += 30;
            }
            if (imageUrl.includes('avatar') || imageUrl.includes('profile')) {
                score += 25;
            }
            if (imageUrl.includes('narrator-portrait')) {
                score += 40;
            }
            if (imageUrl.includes('sndcdn.com/avatars')) {
                score += 35;
            }
            if (imageUrl.includes('wikipedia') || imageUrl.includes('wikimedia')) {
                score += 25;
            }
            if (imageUrl.includes('500') || imageUrl.includes('400') || imageUrl.includes('1080')) {
                score += 10;
            }
            
            return score;
        }

        // Smart name capitalization
        function capitalizeName(name) {
            // Handle special prefixes that should have internal caps
            const specialPrefixes = ['mc', 'mac', "o'"];
            
            return name.split(/\s+/).map(word => {
                if (!word) return '';
                
                // Check if word is all caps and 2-3 characters (likely initials like RC, JK, etc)
                if (word.length <= 3 && word === word.toUpperCase() && /^[A-Z]+$/.test(word)) {
                    return word; // Keep initials as-is
                }
                
                let result = word.toLowerCase();
                
                // Check for special prefixes
                for (const prefix of specialPrefixes) {
                    if (result.startsWith(prefix) && result.length > prefix.length) {
                        // Capitalize first letter and letter after prefix
                        result = prefix.charAt(0).toUpperCase() + 
                                 prefix.slice(1) + 
                                 result.charAt(prefix.length).toUpperCase() + 
                                 result.slice(prefix.length + 1);
                        return result;
                    }
                }
                
                // Handle hyphenated names (e.g., "Mary-Jane")
                if (result.includes('-')) {
                    return result.split('-')
                        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
                        .join('-');
                }
                
                // Standard capitalization
                return result.charAt(0).toUpperCase() + result.slice(1);
            }).join(' ');
        }

        // Merge results - keep all images and bios for selection
        function mergeResults(name, results) {
            // Use properly capitalized name from input
            const properName = capitalizeName(name);
            
            const merged = {
                name: properName,  // Always use the name the user typed in
                images: [],      // All found images with source info
                bios: [],        // All found bios with source info
                selectedImage: null,
                selectedBio: null,
                tagline: null,
                books: [],
                awards: [],
                accents: [],
                genres: [],
                sources: []
            };

            for (const result of results.filter(r => r !== null)) {
                merged.sources.push({ name: result.source, url: result.url });

                // Collect image with score and source
                if (result.imageUrl) {
                    const score = scoreImage(result.imageUrl, result.source);
                    // Only include images with positive scores (negative = blocked)
                    if (score > 0) {
                        merged.images.push({ 
                            url: result.imageUrl, 
                            source: result.source, 
                            score,
                            sourceUrl: result.url 
                        });
                        log(`Image from ${result.source}: score ${score}`);
                    } else {
                        log(`Image from ${result.source}: BLOCKED (score ${score})`, 'error');
                    }
                }

                // Collect bio with source
                if (result.bio && result.bio.length > 20) {
                    // Check if we already have a very similar bio
                    const isDuplicate = merged.bios.some(b => 
                        b.text.substring(0, 100) === result.bio.substring(0, 100)
                    );
                    if (!isDuplicate) {
                        merged.bios.push({
                            text: result.bio,
                            source: result.source,
                            sourceUrl: result.url,
                            length: result.bio.length
                        });
                    }
                }

                if (result.tagline && !merged.tagline) {
                    // Filter out HTML attributes that might have been incorrectly extracted
                    if (!result.tagline.includes('itemtype') && 
                        !result.tagline.includes('schema.org') &&
                        !result.tagline.includes('http') &&
                        !result.tagline.includes('class=') &&
                        !result.tagline.includes('://')) {
                        merged.tagline = result.tagline;
                    }
                }

                if (result.books) {
                    result.books.forEach(b => {
                        if (!merged.books.includes(b)) merged.books.push(b);
                    });
                }

                if (result.awards) {
                    result.awards.forEach(a => {
                        if (!merged.awards.some(x => x.toLowerCase() === a.toLowerCase())) {
                            merged.awards.push(a);
                        }
                    });
                }

                if (result.accents) {
                    result.accents.forEach(a => {
                        if (!merged.accents.includes(a)) merged.accents.push(a);
                    });
                }

                if (result.genres) {
                    result.genres.forEach(g => {
                        if (!merged.genres.includes(g)) merged.genres.push(g);
                    });
                }
            }

            // Sort images by score (best first)
            merged.images.sort((a, b) => b.score - a.score);
            
            // Sort bios by length (longest first, usually most detailed)
            merged.bios.sort((a, b) => b.length - a.length);

            // Log rankings
            if (merged.images.length > 0) {
                log(`--- Image Rankings ---`);
                merged.images.forEach((img, i) => {
                    log(`${i+1}. [${img.source}] Score: ${img.score} - ${img.url.substring(0, 60)}...`);
                });
                log(`----------------------`);
                // Pre-select best image
                merged.selectedImage = 0;
            }
            
            if (merged.bios.length > 0) {
                log(`--- Bio Rankings ---`);
                merged.bios.forEach((bio, i) => {
                    log(`${i+1}. [${bio.source}] ${bio.length} chars`);
                });
                log(`----------------------`);
                // Pre-select longest bio
                merged.selectedBio = 0;
            }

            return merged;
        }

        async function performSearch(skipDatabaseCheck = false) {
            const narratorName = searchInput.value.trim();
            if (!narratorName) {
                showError('Please enter a narrator name');
                return;
            }

            // Reset UI
            debugLog.innerHTML = '';
            loading.classList.add('active');
            resultCard.classList.remove('active');
            document.getElementById('existingProfileCard').style.display = 'none';
            errorMessage.classList.remove('active');
            suggestions.style.display = 'none';
            searchBtn.disabled = true;

            log(`Starting search for "${narratorName}"`);

            // Check if narrator exists in database first (unless skipping for change request)
            if (!skipDatabaseCheck) {
                log('Checking LitLyric database...', 'info');
                const existing = await checkExistingNarrator(narratorName);
                
                if (existing) {
                    // Show existing profile instead of searching
                    loading.classList.remove('active');
                    searchBtn.disabled = false;
                    displayExistingProfile(existing, narratorName);
                    return;
                }
                
                log('Not found in database, searching external sources...', 'info');
            }

            // Check fast mode
            const fastMode = document.getElementById('fastModeToggle')?.checked || false;
            
            log(`Searching external sources${fastMode ? ' (Fast Mode)' : ''}...`);

            // Setup progress indicators
            sourceProgress.innerHTML = Object.entries(SOURCES).map(([key, src]) =>
                `<span class="source-status" id="status-${key}">${src.icon} ${src.name}</span>`
            ).join('');

            try {
                // Core sources (always search these) - increased timeouts
                const coreSearches = [
                    (async () => {
                        updateSourceStatus('audible', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchAudible(narratorName), 20000);
                            updateSourceStatus('audible', r ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('audible', 'not-found');
                            log(`Audible: Timeout or error`, 'warning');
                            return null;
                        }
                    })(),
                    (async () => {
                        updateSourceStatus('wikipedia', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchWikipedia(narratorName), 15000);
                            updateSourceStatus('wikipedia', r ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('wikipedia', 'not-found');
                            log(`Wikipedia: Timeout or error`, 'warning');
                            return null;
                        }
                    })(),
                    (async () => {
                        updateSourceStatus('audiofile', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchAudioFile(narratorName), 20000);
                            updateSourceStatus('audiofile', r ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('audiofile', 'not-found');
                            log(`AudioFile: Timeout or error`, 'warning');
                            return null;
                        }
                    })(),
                    (async () => {
                        updateSourceStatus('tantor', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchTantor(narratorName), 15000);
                            updateSourceStatus('tantor', r ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('tantor', 'not-found');
                            log(`Tantor: Timeout or error`, 'warning');
                            return null;
                        }
                    })(),
                    (async () => {
                        updateSourceStatus('imdb', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchIMDB(narratorName), 20000);
                            updateSourceStatus('imdb', r?.imageUrl ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('imdb', 'not-found');
                            log(`IMDB: Timeout or error`, 'warning');
                            return null;
                        }
                    })()
                ];
                
                // Additional sources (skip in fast mode)
                const additionalSearches = fastMode ? [] : [
                    (async () => {
                        updateSourceStatus('personalsite', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchPersonalSite(narratorName), 15000);
                            updateSourceStatus('personalsite', r ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('personalsite', 'not-found');
                            return null;
                        }
                    })(),
                    (async () => {
                        updateSourceStatus('voicestoknow', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchVoicesToKnow(narratorName), 15000);
                            updateSourceStatus('voicestoknow', r ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('voicestoknow', 'not-found');
                            return null;
                        }
                    })(),
                    (async () => {
                        updateSourceStatus('soundbooth', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchSoundbooth(narratorName), 15000);
                            updateSourceStatus('soundbooth', r ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('soundbooth', 'not-found');
                            return null;
                        }
                    })(),
                    (async () => {
                        updateSourceStatus('soundcloud', 'searching');
                        try {
                            const r = await fetchWithTimeout(searchSoundCloud(narratorName), 15000);
                            updateSourceStatus('soundcloud', r ? 'found' : 'not-found');
                            return r;
                        } catch (e) {
                            updateSourceStatus('soundcloud', 'not-found');
                            return null;
                        }
                    })()
                ];
                
                // Mark skipped sources in fast mode
                if (fastMode) {
                    ['personalsite', 'voicestoknow', 'soundbooth', 'soundcloud'].forEach(src => {
                        updateSourceStatus(src, 'not-found');
                    });
                }

                const results = await Promise.all([...coreSearches, ...additionalSearches]);
                
                // Check if we have any image at all
                let hasImage = results.some(r => r?.imageUrl);
                
                // If still no image, try Google as last resort
                if (!hasImage) {
                    log('No image found, trying Google...', 'info');
                    updateSourceStatus('google', 'searching');
                    try {
                        const googleResult = await fetchWithTimeout(searchGoogle(narratorName), 20000);
                        updateSourceStatus('google', googleResult ? 'found' : 'not-found');
                        if (googleResult) {
                            results.push(googleResult);
                        }
                    } catch (e) {
                        updateSourceStatus('google', 'not-found');
                        log(`Google: Timeout or error`, 'warning');
                    }
                }
                
                const merged = mergeResults(narratorName, results);

                log(`Search complete. Sources found: ${merged.sources.length}`, 'success');
                log(`Images found: ${merged.images.length}`, merged.images.length > 0 ? 'success' : 'error');
                log(`Bios found: ${merged.bios.length}`, merged.bios.length > 0 ? 'success' : 'error');

                if (merged.sources.length === 0) {
                    showError(`No information found for "${narratorName}". Try checking the spelling.`);
                    return;
                }

                displayResult(merged);

            } catch (error) {
                log(`Search failed: ${error.message}`, 'error');
                showError('An error occurred. Please try again.');
            } finally {
                loading.classList.remove('active');
                searchBtn.disabled = false;
            }
        }

        // Store current result data globally for selection
        let currentData = null;

        async function displayResult(data) {
            currentData = data;
            
            // Check if this is a change request (narrator already exists)
            const isChangeRequest = existingNarratorData !== null;
            
            // Update button visibility
            const newButtons = document.getElementById('newNarratorButtons');
            const existingButtons = document.getElementById('existingNarratorButtons');
            
            if (isChangeRequest) {
                // Show change request buttons
                newButtons.style.display = 'none';
                existingButtons.style.display = 'flex';
            } else {
                // Show upload button for new narrator
                newButtons.style.display = 'flex';
                existingButtons.style.display = 'none';
            }
            
            document.getElementById('narratorName').textContent = data.name;

            // Tagline
            const taglineEl = document.getElementById('narratorTagline');
            if (data.tagline) {
                taglineEl.textContent = `"${data.tagline}"`;
                taglineEl.style.display = 'block';
            } else {
                taglineEl.style.display = 'none';
            }

            // Source badges
            document.getElementById('sourceBadges').innerHTML = data.sources.map(s =>
                `<span class="source-badge">${SOURCES[s.name]?.icon || 'üìÑ'} ${s.name}</span>`
            ).join('');

            // Image options
            const imageOptionsEl = document.getElementById('imageOptions');
            const imageSection = document.getElementById('imageSelectionSection');
            if (data.images.length > 0 || true) {  // Always show section for custom input
                // Add "None" option first, then custom input, then found images
                let imagesHtml = `
                    <div class="image-option ${data.selectedImage === null ? 'selected' : ''}" 
                         data-index="none" onclick="selectImage(null)">
                        <div class="no-image-option">
                            <span>‚úï</span>
                            <small>None</small>
                        </div>
                        <div class="image-option-check">‚úì</div>
                    </div>
                    <div class="image-option ${data.selectedImage === 'custom' ? 'selected' : ''}" 
                         data-index="custom" onclick="selectImage('custom')">
                        <div class="custom-image-option">
                            <span>Ôºã</span>
                            <small>Custom</small>
                        </div>
                        <div class="image-option-check">‚úì</div>
                    </div>
                `;
                imagesHtml += data.images.map((img, i) => `
                    <div class="image-option ${i === data.selectedImage ? 'selected' : ''}" 
                         data-index="${i}" onclick="selectImage(${i})">
                        <img src="${img.url}" alt="Option ${i+1}" 
                             onerror="this.parentElement.style.display='none'">
                        <div class="image-option-info">
                            <div class="image-option-source">${SOURCES[img.source]?.icon || 'üìÑ'} ${img.source}</div>
                            <div class="image-option-score">Score: ${img.score}</div>
                        </div>
                        <div class="image-option-check">‚úì</div>
                    </div>
                `).join('');
                imageOptionsEl.innerHTML = imagesHtml;
                imageSection.style.display = 'block';
            }
            
            // Custom image input
            const customImageInput = document.getElementById('customImageInput');
            customImageInput.style.display = data.selectedImage === 'custom' ? 'block' : 'none';

            // Bio options
            const bioOptionsEl = document.getElementById('bioOptions');
            const bioSection = document.getElementById('bioSelectionSection');
            if (data.bios.length > 0 || true) {  // Always show section for custom input
                // Add "None" option first, then custom, then found bios
                let biosHtml = `
                    <div class="bio-option ${data.selectedBio === null ? 'selected' : ''}" 
                         data-index="none" onclick="selectBio(null)">
                        <div class="bio-option-header">
                            <span class="bio-option-source">‚úï None</span>
                            <div class="bio-option-check">${data.selectedBio === null ? '‚úì' : ''}</div>
                        </div>
                        <p class="bio-option-text" style="color: #666; font-style: italic;">No biography selected</p>
                    </div>
                    <div class="bio-option ${data.selectedBio === 'custom' ? 'selected' : ''}" 
                         data-index="custom" onclick="selectBio('custom')">
                        <div class="bio-option-header">
                            <span class="bio-option-source">Ôºã Custom</span>
                            <div class="bio-option-check">${data.selectedBio === 'custom' ? '‚úì' : ''}</div>
                        </div>
                        <p class="bio-option-text" style="color: #666; font-style: italic;">Write your own biography</p>
                    </div>
                `;
                biosHtml += data.bios.map((bio, i) => `
                    <div class="bio-option ${i === data.selectedBio ? 'selected' : ''}" 
                         data-index="${i}" onclick="selectBio(${i})">
                        <div class="bio-option-header">
                            <span class="bio-option-source">${SOURCES[bio.source]?.icon || 'üìÑ'} ${bio.source}</span>
                            <span class="bio-option-length">${bio.length} chars</span>
                            <div class="bio-option-check">${i === data.selectedBio ? '‚úì' : ''}</div>
                        </div>
                        <p class="bio-option-text">${bio.text}</p>
                    </div>
                `).join('');
                bioOptionsEl.innerHTML = biosHtml;
                bioSection.style.display = 'block';
            }
            
            // Custom bio input
            const customBioInput = document.getElementById('customBioInput');
            customBioInput.style.display = data.selectedBio === 'custom' ? 'block' : 'none';

            // Awards
            const awardsSection = document.getElementById('awardsSection');
            if (data.awards.length > 0) {
                document.getElementById('awardsList').innerHTML = data.awards.map(a =>
                    `<span class="tag award">üèÜ ${a}</span>`
                ).join('');
                awardsSection.style.display = 'block';
            } else {
                awardsSection.style.display = 'none';
            }

            // Accents
            const accentsSection = document.getElementById('accentsSection');
            if (data.accents.length > 0) {
                document.getElementById('accentsList').innerHTML = data.accents.map(a =>
                    `<span class="tag">${a}</span>`
                ).join('');
                accentsSection.style.display = 'block';
            } else {
                accentsSection.style.display = 'none';
            }

            // Genres
            const genresSection = document.getElementById('genresSection');
            if (data.genres.length > 0) {
                document.getElementById('genresList').innerHTML = data.genres.map(g =>
                    `<span class="tag">${g}</span>`
                ).join('');
                genresSection.style.display = 'block';
            } else {
                genresSection.style.display = 'none';
            }

            // Books
            const worksSection = document.getElementById('worksSection');
            if (data.books.length > 0) {
                document.getElementById('worksList').innerHTML = data.books.map(b =>
                    `<span class="tag">${b}</span>`
                ).join('');
                worksSection.style.display = 'block';
            } else {
                worksSection.style.display = 'none';
            }

            // Sources
            document.getElementById('sourcesList').innerHTML = data.sources.map(s =>
                `<a href="${s.url}" target="_blank" class="source-link">${SOURCES[s.name]?.icon || 'üìÑ'} ${s.name}</a>`
            ).join('');

            // Update export data
            updateExportData();

            resultCard.classList.add('active');
        }

        function selectImage(index) {
            if (!currentData) return;
            currentData.selectedImage = index;
            
            // Update UI
            document.querySelectorAll('.image-option').forEach((el) => {
                const elIndex = el.dataset.index;
                const isSelected = (index === null && elIndex === 'none') || 
                                   (index === 'custom' && elIndex === 'custom') ||
                                   (typeof index === 'number' && parseInt(elIndex) === index);
                el.classList.toggle('selected', isSelected);
            });
            
            // Show/hide custom input
            const customInput = document.getElementById('customImageInput');
            customInput.style.display = index === 'custom' ? 'block' : 'none';
            
            updateExportData();
        }

        function selectBio(index) {
            if (!currentData) return;
            currentData.selectedBio = index;
            
            // Update UI
            document.querySelectorAll('.bio-option').forEach((el) => {
                const elIndex = el.dataset.index;
                const isSelected = (index === null && elIndex === 'none') || 
                                   (index === 'custom' && elIndex === 'custom') ||
                                   (typeof index === 'number' && parseInt(elIndex) === index);
                el.classList.toggle('selected', isSelected);
                el.querySelector('.bio-option-check').textContent = isSelected ? '‚úì' : '';
            });
            
            // Show/hide custom input
            const customInput = document.getElementById('customBioInput');
            customInput.style.display = index === 'custom' ? 'block' : 'none';
            
            updateExportData();
        }

        function updateExportData() {
            if (!currentData) return;
            
            let imageUrl = null;
            let imageSource = null;
            let bio = null;
            let bioSource = null;
            
            // Handle image selection
            if (currentData.selectedImage === 'custom') {
                // Check for uploaded image first (stored as base64)
                const uploadedImage = currentData.customImageData;
                const customUrl = document.getElementById('customImageUrl')?.value?.trim();
                
                if (uploadedImage) {
                    imageUrl = uploadedImage;
                    imageSource = 'custom-upload';
                } else if (customUrl) {
                    imageUrl = customUrl;
                    imageSource = 'custom';
                }
                
                // Update preview
                const preview = document.getElementById('customImagePreview');
                if (preview && (uploadedImage || customUrl)) {
                    preview.innerHTML = `<img src="${uploadedImage || customUrl}" alt="Preview" onerror="this.style.display='none'">`;
                } else if (preview) {
                    preview.innerHTML = '';
                }
            } else if (currentData.selectedImage !== null && typeof currentData.selectedImage === 'number') {
                const selectedImg = currentData.images[currentData.selectedImage];
                imageUrl = selectedImg?.url || null;
                imageSource = selectedImg?.source || null;
            }
            
            // Handle bio selection
            if (currentData.selectedBio === 'custom') {
                const customBio = document.getElementById('customBioText')?.value?.trim();
                if (customBio) {
                    bio = customBio;
                    bioSource = 'custom';
                }
            } else if (currentData.selectedBio !== null && typeof currentData.selectedBio === 'number') {
                const selectedBio = currentData.bios[currentData.selectedBio];
                bio = selectedBio?.text || null;
                bioSource = selectedBio?.source || null;
            }
            
            const exportObj = {
                name: currentData.name,
                imageUrl: imageUrl,
                imageSource: imageSource,
                bio: bio,
                bioSource: bioSource,
                awards: currentData.awards,
                accents: currentData.accents,
                genres: currentData.genres,
                books: currentData.books,
                sources: currentData.sources.map(s => s.url)
            };
            
            document.getElementById('exportData').textContent = JSON.stringify(exportObj, null, 2);
        }

        // Tab switching for custom image input
        function switchImageTab(tab) {
            const urlTab = document.getElementById('imageUrlTab');
            const uploadTab = document.getElementById('imageUploadTab');
            const buttons = document.querySelectorAll('.custom-image-tabs .tab-btn');
            
            buttons.forEach(btn => btn.classList.remove('active'));
            
            if (tab === 'url') {
                urlTab.style.display = 'block';
                uploadTab.style.display = 'none';
                buttons[0].classList.add('active');
                // Clear uploaded image when switching to URL
                if (currentData) {
                    currentData.customImageData = null;
                }
            } else {
                urlTab.style.display = 'none';
                uploadTab.style.display = 'block';
                buttons[1].classList.add('active');
                // Clear URL when switching to upload
                document.getElementById('customImageUrl').value = '';
            }
            updateExportData();
        }

        // File upload handlers
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drag-over');
        }

        function handleFileDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drag-over');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                processImageFile(files[0]);
            }
        }

        function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                processImageFile(files[0]);
            }
        }

        function processImageFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            // Limit file size to 5MB
            if (file.size > 5 * 1024 * 1024) {
                alert('Image file must be less than 5MB');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64Data = e.target.result;
                
                // Store in currentData
                if (currentData) {
                    currentData.customImageData = base64Data;
                }
                
                // Update preview
                const preview = document.getElementById('customImagePreview');
                preview.innerHTML = `<img src="${base64Data}" alt="Uploaded preview">`;
                
                // Update the upload area to show file name
                const uploadArea = document.getElementById('fileUploadArea');
                uploadArea.innerHTML = `
                    <span class="upload-icon">‚úì</span>
                    <span>${file.name}</span>
                    <small>Click to change</small>
                `;
                
                updateExportData();
            };
            reader.readAsDataURL(file);
        }

        // Copy button handler
        document.getElementById('copyBtn').addEventListener('click', () => {
            const exportText = document.getElementById('exportData').textContent;
            navigator.clipboard.writeText(exportText).then(() => {
                const btn = document.getElementById('copyBtn');
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy JSON', 2000);
            });
        });

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('active');
            suggestions.style.display = 'block';
        }

        // Firebase Functions - Hardcoded config for LitLyric community database
        let firebaseApp = null;
        let firestore = null;
        let storage = null;
        
        // Hardcoded Firebase configuration
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyDPKVYX_lPfpPMfwF0ViesSr0YizYZyAX8",
            authDomain: "litlyric-narrator-batabase.firebaseapp.com",
            projectId: "litlyric-narrator-batabase",
            storageBucket: "litlyric-narrator-batabase.firebasestorage.app",
            messagingSenderId: "312216800042",
            appId: "1:312216800042:web:9b90057de27703b4b1ac53"
        };
        
        const COLLECTION_NAME = 'narrators';
        const CHANGE_REQUESTS_COLLECTION = 'change_requests';
        const REPORTS_COLLECTION = 'reports';
        
        // Track if current narrator exists in database
        let existingNarratorData = null;

        function toggleFirebaseConfig() {
            // No longer needed - config is hardcoded
        }

        function saveFirebaseConfig() {
            // No longer needed - config is hardcoded
        }

        function loadFirebaseConfig() {
            // Auto-initialize with hardcoded config
            initFirebase();
        }

        function initFirebase() {
            try {
                // Delete existing app if any
                if (firebaseApp) {
                    firebaseApp.delete();
                }
                
                firebaseApp = firebase.initializeApp(FIREBASE_CONFIG);
                firestore = firebase.firestore();
                storage = firebase.storage();
                
                console.log('Firebase initialized successfully');
                return true;
            } catch (error) {
                console.error('Firebase init error:', error);
                showFirebaseStatus('Failed to initialize Firebase: ' + error.message, 'error');
                return false;
            }
        }

        function showFirebaseStatus(message, type) {
            const status = document.getElementById('firebaseStatus');
            status.textContent = message;
            status.className = 'firebase-status show ' + type;
            
            if (type === 'success') {
                setTimeout(() => {
                    status.classList.remove('show');
                }, 5000);
            }
        }

        async function uploadToFirebase() {
            if (!currentData) {
                showFirebaseStatus('No narrator data to upload', 'error');
                return;
            }
            
            // Initialize Firebase if not already done
            if (!firestore) {
                if (!initFirebase()) {
                    return;
                }
            }
            
            const btn = document.getElementById('firebaseBtn');
            btn.disabled = true;
            btn.classList.add('uploading');
            btn.textContent = '‚è≥ Checking...';
            
            try {
                // Get selected data
                let imageUrl = null;
                let bio = null;
                
                if (currentData.selectedImage === 'custom') {
                    const uploadedImage = currentData.customImageData;
                    const customUrl = document.getElementById('customImageUrl')?.value?.trim();
                    imageUrl = uploadedImage || customUrl;
                } else if (currentData.selectedImage !== null && typeof currentData.selectedImage === 'number') {
                    const selectedImg = currentData.images[currentData.selectedImage];
                    imageUrl = selectedImg?.url;
                }
                
                if (currentData.selectedBio === 'custom') {
                    bio = document.getElementById('customBioText')?.value?.trim();
                } else if (currentData.selectedBio !== null && typeof currentData.selectedBio === 'number') {
                    const selectedBio = currentData.bios[currentData.selectedBio];
                    bio = selectedBio?.text;
                }
                
                // Create searchable document ID from name
                const docId = currentData.name
                    .toLowerCase()
                    .trim()
                    .replace(/[^a-z0-9\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-');
                
                // Check if narrator already exists
                const existingDoc = await firestore.collection(COLLECTION_NAME).doc(docId).get();
                
                if (existingDoc.exists) {
                    btn.classList.remove('uploading');
                    btn.textContent = 'üî• Upload to Firebase';
                    btn.disabled = false;
                    showFirebaseStatus('This narrator already exists. Use "Request Change" to suggest updates.', 'error');
                    return;
                }
                
                // Upload image to Firebase Storage
                let storedImageUrl = null;
                
                if (imageUrl && storage) {
                    btn.textContent = '‚è≥ Uploading image...';
                    showFirebaseStatus('Uploading image to Storage...', 'success');
                    
                    try {
                        const storageRef = storage.ref(`narrator-images/${docId}.jpg`);
                        const metadata = { contentType: 'image/jpeg' };
                        
                        if (imageUrl.startsWith('data:')) {
                            // Base64 image - upload directly with metadata
                            await storageRef.putString(imageUrl, 'data_url', metadata);
                            storedImageUrl = await storageRef.getDownloadURL();
                        } else {
                            // External URL - convert to base64 via canvas, then upload
                            try {
                                const base64Data = await fetchImageAsBase64(imageUrl);
                                if (base64Data) {
                                    await storageRef.putString(base64Data, 'data_url', metadata);
                                    storedImageUrl = await storageRef.getDownloadURL();
                                } else {
                                    throw new Error('Failed to convert image');
                                }
                            } catch (fetchError) {
                                console.log('Could not fetch/convert image, storing original URL:', fetchError);
                                storedImageUrl = imageUrl;
                            }
                        }
                        
                        log(`Image uploaded to Storage: ${storedImageUrl}`, 'success');
                    } catch (storageError) {
                        console.error('Storage upload error:', storageError);
                        showFirebaseStatus('Image upload failed, saving URL reference instead...', 'error');
                        storedImageUrl = imageUrl;
                    }
                } else {
                    storedImageUrl = imageUrl;
                }
                
                btn.textContent = '‚è≥ Saving...';
                showFirebaseStatus('Saving to database...', 'success');
                
                // Simple narrator data
                const narratorData = {
                    name: currentData.name,
                    imageUrl: storedImageUrl || null,
                    bio: bio || null,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Add createdAt only if new document
                if (!existingDoc.exists) {
                    narratorData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                }
                
                await firestore.collection(COLLECTION_NAME).doc(docId).set(narratorData, { merge: true });
                
                btn.classList.remove('uploading');
                btn.classList.add('success');
                btn.textContent = '‚úì Uploaded to Database';
                showFirebaseStatus(`Successfully saved "${currentData.name}" (ID: ${docId})`, 'success');
                
                // Keep success state - don't reset button
                
            } catch (error) {
                console.error('Upload error:', error);
                btn.classList.remove('uploading');
                btn.classList.add('error');
                btn.textContent = '‚úó Failed';
                showFirebaseStatus('Upload failed: ' + error.message, 'error');
                
                setTimeout(() => {
                    btn.classList.remove('error');
                    btn.textContent = 'üî• Upload to Firebase';
                    btn.disabled = false;
                }, 3000);
            }
        }

        // Load Firebase config on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadFirebaseConfig();
            
            // Check for search parameter in URL and auto-search
            const urlParams = new URLSearchParams(window.location.search);
            const searchParam = urlParams.get('search');
            if (searchParam) {
                searchInput.value = searchParam;
                // Small delay to ensure everything is loaded
                setTimeout(() => {
                    performSearch();
                }, 500);
            }
        });

        // AI Bio Generation
        async function generateAIBio() {
            if (!currentData) {
                log('No narrator data available', 'error');
                return;
            }
            
            const btn = document.getElementById('aiGenerateBtn');
            btn.disabled = true;
            btn.classList.add('generating');
            btn.textContent = '‚ú® Generating...';
            
            log('Starting AI bio generation...', 'info');
            
            try {
                // Gather all available information about the narrator
                const existingBios = currentData.bios.map(b => `[${b.source}]: ${b.text}`).join('\n\n');
                const awards = currentData.awards?.join(', ') || '';
                const genres = currentData.genres?.join(', ') || '';
                const books = currentData.books?.slice(0, 10).join(', ') || '';
                
                // Randomize the style slightly
                const styles = [
                    'conversational and warm',
                    'professional yet personable', 
                    'engaging and descriptive',
                    'concise and informative'
                ];
                const randomStyle = styles[Math.floor(Math.random() * styles.length)];
                
                const openings = [
                    'Start with what makes them unique.',
                    'Lead with their most notable achievement or characteristic.',
                    'Begin by setting the scene of their career.',
                    'Open with their signature style or specialty.'
                ];
                const randomOpening = openings[Math.floor(Math.random() * openings.length)];
                
                const prompt = `Create a unique biography for audiobook narrator "${currentData.name}".

SOURCE MATERIAL:
${existingBios || 'Limited information available.'}
${awards ? `Awards: ${awards}` : ''}
${genres ? `Genres: ${genres}` : ''}
${books ? `Notable audiobooks: ${books}` : ''}

WRITING GUIDELINES:
- Tone: ${randomStyle}
- ${randomOpening}
- Vary sentence length and structure naturally
- 100-200 words, 1-2 paragraphs
- Only include facts from the source material above
- Don't use clich√© phrases like "brings characters to life" or "captivates listeners"
- Avoid starting with their full name - use pronouns or creative alternatives
- No bullet points or lists

Write the bio now:`;

                // Use Netlify serverless function (API key hidden on server)
                const response = await fetch('/api/gemini', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: prompt }]
                        }],
                        generationConfig: {
                            temperature: 0.9,
                            maxOutputTokens: 400
                        }
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    log(`AI API error: ${response.status} - ${JSON.stringify(data)}`, 'error');
                    throw new Error(`AI API failed: ${data.error?.message || response.status}`);
                }
                
                const generatedBio = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                
                if (!generatedBio) {
                    log(`AI response structure: ${JSON.stringify(data).substring(0, 200)}`, 'error');
                    throw new Error('No bio generated');
                }
                
                log(`AI bio generated: ${generatedBio.length} chars`, 'success');
                
                // Add to bios list
                currentData.bios.unshift({
                    source: 'AI Generated',
                    text: generatedBio,
                    length: generatedBio.length
                });
                
                // Re-render bio options and select the AI one
                renderBioOptions();
                selectBio(0);
                
                btn.textContent = '‚úì Generated!';
                setTimeout(() => {
                    btn.textContent = '‚ú® Generate Bio with AI';
                    btn.disabled = false;
                    btn.classList.remove('generating');
                }, 2000);
                
            } catch (error) {
                log(`AI generation failed: ${error.message}`, 'error');
                btn.textContent = '‚úó Failed';
                setTimeout(() => {
                    btn.textContent = '‚ú® Generate Bio with AI';
                    btn.disabled = false;
                    btn.classList.remove('generating');
                }, 2000);
            }
        }
        
        // Re-render bio options (used after AI generation)
        function renderBioOptions() {
            const bioOptionsEl = document.getElementById('bioOptions');
            if (!currentData || !currentData.bios) return;
            
            let biosHtml = '';
            currentData.bios.forEach((bio, index) => {
                const isSelected = currentData.selectedBio === index;
                const isAI = bio.source === 'AI Generated';
                biosHtml += `
                    <div class="bio-option ${isSelected ? 'selected' : ''}" 
                         onclick="selectBio(${index})" 
                         data-index="${index}"
                         style="${isAI ? 'border-color: #667eea; background: rgba(102, 126, 234, 0.1);' : ''}">
                        <div class="bio-option-header">
                            <span class="bio-source">${isAI ? '‚ú® ' : ''}${bio.source}</span>
                            <span class="bio-length">${bio.length} chars</span>
                        </div>
                        <div class="bio-option-text">${bio.text}</div>
                        <div class="bio-option-check">‚úì</div>
                    </div>
                `;
            });
            
            if (biosHtml === '') {
                biosHtml = '<p style="color: #6b7280; text-align: center;">No biographies found. Try the AI generator above!</p>';
            }
            
            bioOptionsEl.innerHTML = biosHtml;
        }

        // Timeout wrapper for fetch operations
        function fetchWithTimeout(promise, timeoutMs = 8000) {
            return Promise.race([
                promise,
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout')), timeoutMs)
                )
            ]);
        }

        // Check if narrator exists in Firebase database
        async function checkExistingNarrator(name) {
            if (!firestore) {
                if (!initFirebase()) return null;
            }
            
            const docId = name
                .toLowerCase()
                .trim()
                .replace(/[^a-z0-9\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-');
            
            try {
                const doc = await firestore.collection(COLLECTION_NAME).doc(docId).get();
                if (doc.exists) {
                    log(`Found "${name}" in database`, 'success');
                    return { id: docId, ...doc.data() };
                }
            } catch (error) {
                log(`Error checking database: ${error.message}`, 'error');
            }
            return null;
        }

        // Display existing narrator profile
        function displayExistingProfile(data, searchName) {
            existingNarratorData = data;
            
            const card = document.getElementById('existingProfileCard');
            const img = document.getElementById('existingImage');
            const noImg = document.getElementById('existingNoImage');
            const name = document.getElementById('existingNarratorName');
            const bio = document.getElementById('existingBio');
            const noBio = document.getElementById('existingNoBio');
            
            // Set name
            name.textContent = data.name || searchName;
            
            // Set image
            if (data.imageUrl) {
                img.src = data.imageUrl;
                img.style.display = 'block';
                noImg.style.display = 'none';
            } else {
                img.style.display = 'none';
                noImg.style.display = 'flex';
            }
            
            // Set bio
            if (data.bio) {
                bio.textContent = data.bio;
                bio.style.display = 'block';
                noBio.style.display = 'none';
            } else {
                bio.style.display = 'none';
                noBio.style.display = 'block';
            }
            
            card.style.display = 'block';
            log('Displaying existing profile from database', 'success');
        }

        // Start change request - runs the normal search
        function startChangeRequest() {
            log('Starting change request - searching external sources...', 'info');
            document.getElementById('existingProfileCard').style.display = 'none';
            
            // Run search but skip database check
            performSearch(true);
        }

        // Modal functions
        function showRequestChangeModal() {
            // This modal asks for optional reason/email before submitting
            document.getElementById('requestChangeModal').style.display = 'flex';
        }

        function closeRequestChangeModal() {
            document.getElementById('requestChangeModal').style.display = 'none';
            document.getElementById('changeReason').value = '';
            document.getElementById('changeEmail').value = '';
        }

        function showReportModal() {
            document.getElementById('reportModal').style.display = 'flex';
        }

        function closeReportModal() {
            document.getElementById('reportModal').style.display = 'none';
            // Reset form
            document.querySelectorAll('input[name="reportReason"]').forEach(r => r.checked = false);
            document.getElementById('reportDetails').value = '';
            document.getElementById('reportEmail').value = '';
        }

        // Submit change request - uses currently selected image/bio
        async function submitChangeRequest() {
            if (!currentData || !existingNarratorData) {
                showFirebaseStatus('No data to submit', 'error');
                return;
            }

            const reason = document.getElementById('changeReason').value.trim();
            const email = document.getElementById('changeEmail').value.trim();

            if (!firestore) {
                if (!initFirebase()) return;
            }

            const btn = document.querySelector('#requestChangeModal .modal-submit');
            btn.disabled = true;
            btn.textContent = 'Submitting...';

            try {
                // Get selected data
                let newImageUrl = null;
                let newBio = null;

                // Debug logging
                log(`Selected image index: ${currentData.selectedImage}`, 'info');
                log(`Selected bio index: ${currentData.selectedBio}`, 'info');

                // Handle image selection
                if (currentData.selectedImage === 'custom') {
                    newImageUrl = currentData.customImageData || document.getElementById('customImageUrl')?.value?.trim();
                    log(`Custom image URL: ${newImageUrl ? 'yes' : 'no'}`, 'info');
                } else if (typeof currentData.selectedImage === 'number' && currentData.selectedImage >= 0) {
                    newImageUrl = currentData.images[currentData.selectedImage]?.url;
                    log(`Image from index ${currentData.selectedImage}: ${newImageUrl ? newImageUrl.substring(0, 50) + '...' : 'none'}`, 'info');
                }

                // Handle bio selection
                if (currentData.selectedBio === 'custom') {
                    newBio = document.getElementById('customBioText')?.value?.trim();
                } else if (typeof currentData.selectedBio === 'number' && currentData.selectedBio >= 0) {
                    newBio = currentData.bios[currentData.selectedBio]?.text;
                }

                // Warn if nothing selected
                if (!newImageUrl && !newBio) {
                    showFirebaseStatus('Please select an image or bio to submit', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Submit for Review';
                    return;
                }

                log(`Submitting - Image: ${newImageUrl ? 'yes' : 'no'}, Bio: ${newBio ? 'yes' : 'no'}`, 'info');

                const changeRequest = {
                    narratorId: existingNarratorData.id,
                    narratorName: currentData.name,
                    currentData: {
                        imageUrl: existingNarratorData.imageUrl || null,
                        bio: existingNarratorData.bio || null
                    },
                    proposedChanges: {
                        imageUrl: newImageUrl || null,
                        bio: newBio || null
                    },
                    reason: reason || null,
                    submitterEmail: email || null,
                    status: 'pending',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                await firestore.collection(CHANGE_REQUESTS_COLLECTION).add(changeRequest);

                btn.textContent = '‚úì Submitted!';
                showFirebaseStatus('Change request submitted for review!', 'success');
                log('Change request submitted successfully', 'success');

                setTimeout(() => {
                    closeRequestChangeModal();
                    btn.disabled = false;
                    btn.textContent = 'Submit Request';
                }, 2000);

            } catch (error) {
                console.error('Submit error:', error);
                btn.textContent = 'Failed';
                showFirebaseStatus('Failed to submit: ' + error.message, 'error');
                
                setTimeout(() => {
                    btn.disabled = false;
                    btn.textContent = 'Submit Request';
                }, 2000);
            }
        }

        // Submit report
        async function submitReport() {
            if (!existingNarratorData) {
                showFirebaseStatus('No narrator data to report', 'error');
                return;
            }

            const reasonEl = document.querySelector('input[name="reportReason"]:checked');
            const details = document.getElementById('reportDetails').value.trim();
            const email = document.getElementById('reportEmail').value.trim();

            if (!reasonEl) {
                alert('Please select a reason for the report.');
                return;
            }

            if (!firestore) {
                if (!initFirebase()) return;
            }

            const btn = document.querySelector('#reportModal .modal-submit');
            btn.disabled = true;
            btn.textContent = 'Submitting...';

            try {
                const report = {
                    narratorId: existingNarratorData.id,
                    narratorName: existingNarratorData.name || 'Unknown',
                    currentData: {
                        imageUrl: existingNarratorData.imageUrl || null,
                        bio: existingNarratorData.bio || null
                    },
                    reason: reasonEl.value,
                    details: details || null,
                    submitterEmail: email || null,
                    status: 'pending',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                await firestore.collection(REPORTS_COLLECTION).add(report);

                btn.textContent = '‚úì Reported!';
                showFirebaseStatus('Report submitted. Thank you for helping keep the database accurate!', 'success');
                log('Report submitted successfully', 'success');

                setTimeout(() => {
                    closeReportModal();
                    btn.disabled = false;
                    btn.textContent = 'Submit Report';
                }, 2000);

            } catch (error) {
                console.error('Report error:', error);
                btn.textContent = 'Failed';
                showFirebaseStatus('Failed to submit report: ' + error.message, 'error');
                
                setTimeout(() => {
                    btn.disabled = false;
                    btn.textContent = 'Submit Report';
                }, 2000);
            }
        }

        // Close modals when clicking outside
        document.getElementById('requestChangeModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'requestChangeModal') closeRequestChangeModal();
        });
        
        document.getElementById('reportModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'reportModal') closeReportModal();
        });
    </script>
</body>
</html>
